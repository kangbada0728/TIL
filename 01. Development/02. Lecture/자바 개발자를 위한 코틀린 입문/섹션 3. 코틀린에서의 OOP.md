---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_최태현
  - 자바_개발자를_위한_코틀린_입문
  - Kotlin
---
# 9강. 코틀린에서 클래스를 다루는 방법

## 1. 클래스와 프로퍼티

### Java 코드

```java
public class JavaPerson {  
  
    private final String name;  
    private int age;  
  
    public JavaPerson(String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    public JavaPerson(String name) {  
        this(name, 1);  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
}
```

### Kotlin 코드

- 프로퍼티 = 필드 + getter + setter
- Kotlin 에서는 필드만 만들면 getter, setter 를 자동으로 만들어준다.

```kotlin
class Person constructor(name: String, age: Int){  
  
    val name = name  
    var age = age  
  
}
```

- 여기서 constructor 라는 지시어는 생략 가능하다.

```kotlin
class Person(name: String, age: Int){  
  
    val name = name  
    var age = age  
  
}
```

- Kotlin 에서 생성자를 만들어 줄 때 프로퍼티를 선언할 수 있다.

```kotlin
class Person(val name: String, var age: Int){

}
```

- 위에 body 에는 아무것도 들어가있지 않기 때문에 생략 가능하다.

```kotlin
class Person(val name: String, var age: Int)
```

- (점)필드 를 통해 getter 와 setter 를 바로 호출가능하다.
- Java 클래스에 대해서도 (점)필드로 getter, setter 를 사용한다.

```kotlin
val person = Person("최태현", 100)
println(person.name) // 최태현
person.age = 10
println(person.age) // 10
```

## 2. 생성자와 init

- 생성자 안에 검증로직을 넣기 위해서는 init 이라는 블록을 사용하면 된다.
- 이 블록은 생성자가 호출되는 시점에 한 번 호출되는 블록이다.
- 그래서 Validation 을 하거나 값을 적절히 만들어주는 용도로 사용된다.

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
}
```

- 주생성자는 Class 이름 옆에 작성하지만, 부생성자들은 constructor 라는 키워드와 함께 만들어져야 한다.
- 주생성자(primary constructor) 는 반드시 존재해야 한다.
	- 단, 주생성자에 파라미터가 하나도 없다면 생략 가능하다.
- 부생성자(secondary constructor)는 최종적으로 주생성자를 this 로 호출해야 한다.

- 아래와 같이 생성자가 연쇄적으로 이어져 있는 경우 body 의 호출 순서는 생성자 호출 순서의 역순이다.
- 다만 Kotlin 에서는 부생성자보다는 default parameter 를 권장한다.
	- constructor 의 default parameter 를 넣어서 parameter 를 쓰지 않을 경우, 기본값을 쓰게 하는 것이 더 깔끔하기 때문이다.
	- 타 객체를 현 객체로 변환해야하는 Converting 과 같은 경우 부생성자를 사용할 수 있지만, 정적 팩토리 메소드를 추천한다.

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
  
    constructor(name: String): this(name, 1) // 기본 생성자를 호출한다.
	constructor() : this("홍길동") { // body 를 만들어서 코드를 넣을수도 있다.
	    println("두번째 부생성자")  
	}
}
```

## 3. 커스텀 getter, setter

- age 가 19가 넘었는지 확인하는 메소드를 만든다고 해보자.
- 물론 Kotlin 에서도 Java 에서 했던 것처럼 만들어도 된다.
- 그런데 다른 방법도 있다.
- 마치 이 Person 클래스에 관련 프로퍼티가 있는 것처럼 보여주는 것이다.

- 아래 3가지 방법은 모두 동일한 기능이고 표현 방법만 다르다. (가독성)

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
  
    fun isAdult1(): Boolean { // 일반 방법
        return this.age >= 20  
    }  
  
    val isAdult2: Boolean // expression 사용방법
        get() = this.age >= 20  
    
    val isAdult3: Boolean // return 사용방법
        get() {  
            return this.age >= 20  
        }  
}
```

- 프로퍼티에 대한 getter 를 커스터마이징 해보자.
- 일단 `val name: String` 에서 val 을 없애자.
	- `val name` 이라고 클래스에 선언하게 되면 프로퍼티로 선언되어서 getter 를 자동으로 만들어주기 때문이다.
	- 그래서 getter 가 자동으로 생성되지 말라고 val 을 없애는 것이다.
- 그리고 아래 body 에 `val name` 을 써주고 여기서 `get()` 내용을 적어주면 된다.
- 다만 `name.uppercase()` 라고 쓰는 것이 아니라, `field.uppercase()` 라고 써야한다.
	- name 은 name 에 대한 getter 를 호출하니까 다시 get 을 부르기 때문이다.
	- getter 안에는 다시 name 이 있다.
	- 이런 식으로 무한 루프가 돌기 때문에 자기 자신을 가리키는 field 라는 예약어를 쓰는 것이다.
	- 이러한 field 를 보이지 않는 field 라고 하여 backing field 라고 부른다.
- 아니면 `field.uppercase()` 대신 `this.name.uppercase()` 를 쓸 수도 있다.

```kotlin
class Person(  
    name: String,   
    var age: Int  
) {  
  
    val name = name // 불변 프로퍼티 name 에 대입한다는 뜻
        get() = field.uppercase()
}
```

- 아래와 같이 setter 을 커스터마이징 할 수도 있다.

```kotlin
class Person(  
    name: String,  
    var age: Int  
) {  
  
    var name = name  
        set(value) {  
            field = value.uppercase()  
        }
}
```

- 다만 Setter 자체를 지양하기 때문에 custom setter 도 잘 안쓴다.

# 10강. 코틀린에서 상속을 다루는 방법

## 1. 추상 클래스

### 예제 1

#### Java 코드

```java
public abstract class JavaAnimal {  
  
    protected final String species;  
    protected final int legCount;  
  
    public JavaAnimal(String species, int legCount) {  
        this.species = species;  
        this.legCount = legCount;  
    }  
  
    abstract public void move();  
  
    public String getSpecies() {  
        return species;  
    }  
  
    public int getLegCount() {  
        return legCount;  
    }  
  
}
```

#### Kotlin 코드

```kotlin
abstract class Animal(  
    protected val species: String,  
    protected val legCount: Int,  
) {  
    abstract fun move()  
}
```

### 예제 2

#### Java 코드

```java
public class JavaCat extends JavaAnimal {  
  
    public JavaCat(String species) {  
        super(species, 4);  
    }  
  
    @Override  
    public void move() {  
        System.out.println("고양이가 사뿐 사뿐 걸어가~");  
    }  
  
}
```

#### Kotlin 코드

- Kotlin 에서 상속은 : 을 쓴다.
- 타입을 쓸 때도 : 을 쓰고 상속을 받을 떄도 : 을 쓴다.
	- convention 의 차이는 있다.
		- 타입을 쓸 때는 변수명에서 한 칸 뛰지 않고 : 을 붙인다.
		- 어떤 걸 상속받을 떄는 한 칸 뛰고 : 을 붙인다.

- Kotlin 에서는 어떤 클래스를 상속받을 때 상위 클래스의 생성자를 바로 호출해야 한다.

- Kotlin 에서는 override 라는 annotation 이 아닌 지시어를 사용해야 하며 필수로 붙여줘야 한다.

```kotlin
class Cat(  
    species: String  
) : Animal(species, 4) {  
  
    override fun move() {  
        println("고양이가 사뿐 사뿐 걸어가~")  
    }  
}
```

### 예제 3

#### Java 코드

```java
public final class JavaPenguin extends JavaAnimal {  
  
    private final int wingCount;  
  
    public JavaPenguin(String species) {  
        super(species, 2);  
        this.wingCount = 2;  
    }  
  
    @Override  
    public void move() {  
        System.out.println("펭귄이 움직입니다~ 꿱꿱");  
    }  
  
    @Override  
    public int getLegCount() {  
        return super.legCount + this.wingCount;  
    }
  
}
```

#### Kotlin 코드

```kotlin
class Penguin(  
    species: String  
) : Animal(species, 2) {  
  
    private val wingCount: Int = 2  
  
    override fun move() {  
        println("펭귄이 움직입니다~ 꿱꿱")  
    }  
  
    override val legCount: Int  
        get() = super.legCount + this.wingCount  
}
```

- 그런데 위와 같이 쓰면 `override val legCount: Int` 의 `override` 아래에 컴파일 에러가 난다.
- Kotlin 에서는 Java 와 다르게 프로퍼티를 override 할 때 무조건 open 을 붙여주어야 한다.
	- 추상 프로퍼티가 아니라면, 상속받을 때 open 을 꼭 붙여야 한다.
- 그래서 `protected open val legCount: Int` 에 `open` 을 넣어서 컴파일 에러를 없앴다.

```kotlin
abstract class Animal(  
    protected val species: String,  
    protected open val legCount: Int,  
) {  
    abstract fun move()  
}
```

- Java 와 Kotlin 모두 추상 클래스는 인스턴스화 할 수 없다.

## 2. 인터페이스

### Java 코드

```java
public interface JavaFlyable {  
  
    default void act() {  
        System.out.println("파닥 파닥");  
    }  
  
}
```

```java
public interface JavaSwimable {  
  
    default void act() {  
        System.out.println("어푸 어푸");  
    }  
  
}
```

```java
public final class JavaPenguin extends JavaAnimal implements JavaSwimable, JavaFlyable {  
  
    @Override  
    public void act() {  
        JavaSwimable.super.act();  
        JavaFlyable.super.act();  
    }  
  
}
```

### Kotlin 코드

- default 를 쓰지 않아도 default 함수를 만들 수 있다.
- 추상메서드를 쓰고 싶다면 그냥 `fun act2()` 와 같이 body 없이 쓰면 된다.

```kotlin
interface Flyable {  
  
    fun act() {  
        println("파닥 파닥")  
    }
  
}
```

```kotlin
interface Swimable {  
  
    fun act() {  
        println("어푸 어푸")  
    }  
  
}
```

- Kotlin 에서 인터페이스를 구현하고 싶다면 상속과 마찬가지로 : 을 쓰면 된다.
- 특정 상위 인터페이스의 함수를 override 할 때 문법이 달라졌다.
	- Java 는 `인터페이스타입.super.메소드` 인데,
	- Kotlin 은 `super<타입>.함수` 이다.

```kotlin
class Penguin(  
    species: String  
) : Animal(species, 2), Swimable, Flyable {  
  
    private val wingCount: Int = 2  
  
    override fun move() {  
        println("펭귄이 움직입니다~ 꿱꿱")  
    }  
  
    override val legCount: Int  
        get() = super.legCount + this.wingCount  
  
    override fun act() {  
        super<Swimable>.act()  
        super<Flyable>.act()  
    }  
}
```

- Java, Kotlin 모두 인터페이스를 인스턴스화 할 수 없다.
- Kotlin 에서는 backing field 가 없는 프로퍼티를 Interface 에 만들 수 있다.
	- 아래와 같이 Swimable 인터페이스에 프로퍼티를 만들 수 있다.
	- 이 프로퍼티는 Swimable 에 field 가 있는 것이 아니라, getter 에 대한 것을 구현체에서 구현해주는 것을 기대하는 것이다.
- 이처럼 프로터피라는 것이 field 라는 것도 있지만 getter 라는 것도 있기 때문에 getter 에 대한 default 메소드나 getter 에 대한 추상 메소드를 인터페이스에 만드는 것이라 이렇게 backing field 없는 프로퍼티를 인터페이스에 만들 수 있다.

```kotlin
interface Swimable {  
  
    val swimAbility: Int
	    get() = 3 // 이렇게 기본값을 넣어줄 수도 있다. 기본값이 있으면 오버라이드를 안해도 된다.
  
    fun act() {  
        println("어푸 어푸")  
    }  
  
}
```

```kotlin
class Penguin(  
    species: String  
) : Animal(species, 2), Swimable, Flyable {  
  
    ...
	override val swimAbility: Int
		get() = 3
}
```

## 3. 클래스를 상속할 때 주의점

- 아래 Derived 객체를 생성하면 어떻게 될까?

```kotlin
open class Base( // 다른 클래스가 Base 클래스를 상속할 수 있게 open 해주었다.
    open val number: Int = 100 // number 프로퍼티도 open 하여 override 할 수 있게 open 해주었다.
) {  
    init {  
        println("Base Class")  
        println(number)  
    }  
}
```

```kotlin
class Derived(  
    override val number: Int  
) : Base(number) {  
    init {  
        println("Derived Class")  
    }  
}
```

```
Base Class
0
Derived Class
```

- 상위 클래스에서 하위 클래스가 override 하고 있는 프로퍼티를 생성자 블락이나 init 블락을 쓰게 되면 예상치 못한 값이 나올 수 있다.
- 위 같은 경우는 Base Class 의 생성자가 실행되면서 하위 클래스가 override 하고 있는 number 에 접근해서 출력하려 하는데, 아직 하위 클래스인 Drived 의 number 가 초기화되지 않기 때문에 0 이 나온 것이다.
- 따라서 상위 클래스의 생성자에서는 하위 클래스에서 override 하고 있는 프로퍼티에 접근하면 안된다. (final 프로퍼티는 제외)

> [!tip]
> 상위 클래스를 설계할 떄 생성자 또는 초기화 블록에 사용되는 프로퍼티에는 open 을 피해야 한다.

- 추상 멤버가 아니면 기본적으로 오버라이드가 불가능하다.
	- open 을 사용해주어야 한다.

## 4. 상속 관련 지시어 정리

1. final : override 를 할 수 없게 한다. default 로 보이지 않게 존재한다.
2. open : override 를 열어 준다.
3. abstract : 반드시 override 해야 한다.
4. override : 상위 타입을 오버라이드 하고 있다.

# 11강. 코틀린에서 접근 제어를 다루는 방법
















# 12강. 코틀린에서 object 키워드를 다루는 방법





# 13강. 코틀린에서 중첩 클래스를 다루는 방법





# 14강. 코틀린에서 다양한 클래스를 다루는 방법






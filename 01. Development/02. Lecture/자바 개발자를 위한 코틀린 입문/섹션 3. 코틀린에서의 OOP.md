---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_최태현
  - 자바_개발자를_위한_코틀린_입문
  - Kotlin
---
# 9강. 코틀린에서 클래스를 다루는 방법

## 1. 클래스와 프로퍼티

### Java 코드

```java
public class JavaPerson {  
  
    private final String name;  
    private int age;  
  
    public JavaPerson(String name, int age) {  
        this.name = name;  
        this.age = age;  
    }  
  
    public JavaPerson(String name) {  
        this(name, 1);  
    }  
  
    public String getName() {  
        return name;  
    }  
  
    public int getAge() {  
        return age;  
    }  
  
    public void setAge(int age) {  
        this.age = age;  
    }  
  
}
```

### Kotlin 코드

- 프로퍼티 = 필드 + getter + setter
- Kotlin 에서는 필드만 만들면 getter, setter 를 자동으로 만들어준다.

```kotlin
class Person constructor(name: String, age: Int){  
  
    val name = name  
    var age = age  
  
}
```

- 여기서 constructor 라는 지시어는 생략 가능하다.

```kotlin
class Person(name: String, age: Int){  
  
    val name = name  
    var age = age  
  
}
```

- Kotlin 에서 생성자를 만들어 줄 때 프로퍼티를 선언할 수 있다.

```kotlin
class Person(val name: String, var age: Int){

}
```

- 위에 body 에는 아무것도 들어가있지 않기 때문에 생략 가능하다.

```kotlin
class Person(val name: String, var age: Int)
```

- (점)필드 를 통해 getter 와 setter 를 바로 호출가능하다.
- Java 클래스에 대해서도 (점)필드로 getter, setter 를 사용한다.

```kotlin
val person = Person("최태현", 100)
println(person.name) // 최태현
person.age = 10
println(person.age) // 10
```

## 2. 생성자와 init

- 생성자 안에 검증로직을 넣기 위해서는 init 이라는 블록을 사용하면 된다.
- 이 블록은 생성자가 호출되는 시점에 한 번 호출되는 블록이다.
- 그래서 Validation 을 하거나 값을 적절히 만들어주는 용도로 사용된다.

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
}
```

- 주생성자는 Class 이름 옆에 작성하지만, 부생성자들은 constructor 라는 키워드와 함께 만들어져야 한다.
- 주생성자(primary constructor) 는 반드시 존재해야 한다.
	- 단, 주생성자에 파라미터가 하나도 없다면 생략 가능하다.
- 부생성자(secondary constructor)는 최종적으로 주생성자를 this 로 호출해야 한다.

- 아래와 같이 생성자가 연쇄적으로 이어져 있는 경우 body 의 호출 순서는 생성자 호출 순서의 역순이다.
- 다만 Kotlin 에서는 부생성자보다는 default parameter 를 권장한다.
	- constructor 의 default parameter 를 넣어서 parameter 를 쓰지 않을 경우, 기본값을 쓰게 하는 것이 더 깔끔하기 때문이다.
	- 타 객체를 현 객체로 변환해야하는 Converting 과 같은 경우 부생성자를 사용할 수 있지만, 정적 팩토리 메소드를 추천한다.

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
  
    constructor(name: String): this(name, 1) // 기본 생성자를 호출한다.
	constructor() : this("홍길동") { // body 를 만들어서 코드를 넣을수도 있다.
	    println("두번째 부생성자")  
	}
}
```

## 3. 커스텀 getter, setter

- age 가 19가 넘었는지 확인하는 메소드를 만든다고 해보자.
- 물론 Kotlin 에서도 Java 에서 했던 것처럼 만들어도 된다.
- 그런데 다른 방법도 있다.
- 마치 이 Person 클래스에 관련 프로퍼티가 있는 것처럼 보여주는 것이다.

- 아래 3가지 방법은 모두 동일한 기능이고 표현 방법만 다르다. (가독성)

```kotlin
class Person(val name: String, var age: Int){  
    init {  
        if (age <= 0) {  
            throw IllegalArgumentException("나이는 ${age}일 수 없습니다.")  
        }  
    }  
  
    fun isAdult1(): Boolean { // 일반 방법
        return this.age >= 20  
    }  
  
    val isAdult2: Boolean // expression 사용방법
        get() = this.age >= 20  
    
    val isAdult3: Boolean // return 사용방법
        get() {  
            return this.age >= 20  
        }  
}
```

- 프로퍼티에 대한 getter 를 커스터마이징 해보자.
- 일단 `val name: String` 에서 val 을 없애자.
	- `val name` 이라고 클래스에 선언하게 되면 프로퍼티로 선언되어서 getter 를 자동으로 만들어주기 때문이다.
	- 그래서 getter 가 자동으로 생성되지 말라고 val 을 없애는 것이다.
- 그리고 아래 body 에 `val name` 을 써주고 여기서 `get()` 내용을 적어주면 된다.
- 다만 `name.uppercase()` 라고 쓰는 것이 아니라, `field.uppercase()` 라고 써야한다.
	- name 은 name 에 대한 getter 를 호출하니까 다시 get 을 부르기 때문이다.
	- getter 안에는 다시 name 이 있다.
	- 이런 식으로 무한 루프가 돌기 때문에 자기 자신을 가리키는 field 라는 예약어를 쓰는 것이다.
	- 이러한 field 를 보이지 않는 field 라고 하여 backing field 라고 부른다.
- 아니면 `field.uppercase()` 대신 `this.name.uppercase()` 를 쓸 수도 있다.

```kotlin
class Person(  
    name: String,   
    var age: Int  
) {  
  
    val name = name // 불변 프로퍼티 name 에 대입한다는 뜻
        get() = field.uppercase()
}
```

- 아래와 같이 setter 을 커스터마이징 할 수도 있다.

```kotlin
class Person(  
    name: String,  
    var age: Int  
) {  
  
    var name = name  
        set(value) {  
            field = value.uppercase()  
        }
}
```

- 다만 Setter 자체를 지양하기 때문에 custom setter 도 잘 안쓴다.

# 10강. 코틀린에서 상속을 다루는 방법







# 11강. 코틀린에서 접근 제어를 다루는 방법




# 12강. 코틀린에서 object 키워드를 다루는 방법





# 13강. 코틀린에서 중첩 클래스를 다루는 방법





# 14강. 코틀린에서 다양한 클래스를 다루는 방법






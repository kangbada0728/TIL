---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_최태현
  - 자바_개발자를_위한_코틀린_입문
  - Kotlin
---
# 19강. 코틀린의 이모저모

## 1. Type Alias 와 as import

### Type Alias

- 긴 이름의 클래스 혹은 함수 타입이 있을 떄 축약하거나 더 좋은 이름을 쓰고 싶을 때는 어떻게 해야할까?

- 예를들어, `(Fruit) -> Boolean` 이라는 타입은 너무 길다.
	- 파라미터가 더 많아지면 감당하기 힘들 것 같다.
	- ex) `(Fruit, Fruit, Fruit) -> Boolean`
- 이럴 때 Type Alias 를 사용하면 된다.

```kotlin
fun filterFruits(fruits: List<Fruit>, filter: (Fruit) -> Boolean) {}
// 위의 코드가 아래처럼 바뀐다.
typealias FruitFilter = (Fruit) -> Boolean
fun filterFruits(fruits: List<Fruit>, filter: FruitFilter) {}
```

- 이름 긴 클래스를 컬렉션에 사용할 때도 간단히 줄일 수 있다.

```kotlin
data class UltraSuperGuardianTribe(
	val name: String
)

typealias USGTMap = Map<String, UltraSuperGuardianTribe>
```

### as import

- 다른 패키지의 같은 이름 함수를 동시에 가져오고 싶다면 어떻게 해야할까?
- 이럴 떄는 as import 를 사용해야 한다.
- as import 를 사용하면 Import 와 동시에 이름을 바꿀 수 있다.

> [!note] as import 란
> 어떤 클래스나 함수를 import 할 떄 이름을 바꾸는 기능

```kotlin
import com.lannstark.lec19.a.aprintHelloWorld as printHelloWorldA
import com.lannstark.lec19.b.aprintHelloWorld as printHelloWorldB

fun main() {
	printHelloWorldA()
	printHelloWorldB()
}
```

## 2. 구조 분해와 componentN 함수

> [!note] 구조 분해란
> 복합적인 값을 분해하여 여러 변수를 한 번에 초기화하는 것

```kotlin
data class Person(
	val name: String,
	val age: Int
)

val person = Person("최태현", 100)
val (name, age) = person
```

- Data Class 는 componentN 이란 함수도 자동으로 만들어준다.
- 위 코드를 분해하면 아래와 같다.

```kotlin
// val (name, age) = pserson
val name = person.component1()
val age = person.component2()
```

- Data Class 는 기본적으로 자기가 가지고 있는 field 에 대해서 componentN 이라는 함수륾 만들어준다.
	- 예를 들어, component1 은 첫 번째 프로퍼티를 가져오는 것이고
	- component2 은 첫 번째 프로퍼티를 가져오는 것이다.
- 구조분해 문법을 쓴다는 것은 componentN 함수를 호출한다는 뜻이다.


- Data Class 가 아닌데 구조분해를 사용하고 싶다면, componentN 함수를 직접 구현해줄 수도 있다.

```kotlin
class Person(
	val name: String,
	val age: Int
) {
	operator fun component1(): String {
		return this.name
	}

	operator fun component2(): Int {
		return this.age
	}
}
```

- 참고로 아래 문법도 구조분해이다.

```kotlin
val map = mapOf(1 to "A", 2 to "B")
for ((key, value) in map.entries) {

}
```

## 3. Jump 와 Label

### Jump

> [!note]
> - return : 기본적으로 가장 가까운 enclosing function 또는 익명함수로 값이 반환된다.
> - break : 가장 가까운 루프가 제거된다.
> - continue : 가장 가까운 루프를 다음 step 으로 보낸다.

- for 문 및 whilte 문에서 break, continue 기능은 동일하다.
- 단, forEach 구문에서는 continue, break 를 쓸 수 없다.

- 꼭 써야한다면 아래와 같이 써야한다.

- break 를 쓰려면 run 이라는 블록으로 forEach 를 한번 감싼 뒤 return@run 으로 break 를 걸어야 한다.

```kotlin
val numbers = listOf(1, 2, 3, 4, 5)
run {
	numbers.forEach { number ->
		if (number == 3) {
			return@run
		}
		println(number)
	}
}
```

- continue 를 쓰려면 return@forEach 를 써야 한다.
- return@forEach 는 continue 를 쓴 효과를 보여준다.

```kotlin
numbers.forEach { number ->
	if (number == 2) {
		return@forEach
	}
}
```

### Label

- 위와 같은 기능들은 Kotlin 의 Label 이라는 기능을 이용한 것이다.
- 특정 expression 에 `라벨이름@` 을 붙여 하나의 라벨로 간주하고, break, continue, return 등을 사용하는 기능

- 만약 아래와 같이 `abc@` 라는 라벨을 달면 가장 밖에 있는 for 문이 break 된다.

```kotlin
abc@ for (i in 1..100) {  
    for (j in 1..100) {  
        if (j == 2) {  
            break@abc  
        }  
    }  
}
```

- 이렇게 Kotlin 은 Label 을 달 수 있는 기능과 return, continue, break 에 대해 특정 Label 에 대해 동작할 수 있게끔 하는 기능있다.
- 라벨을 사용한 Jump 는 사용하지 말자.

## 4. TakeIf 와 TakeUnless

- Kotlin 에서는 method chaning 을 위한 함수를 제공한다.
- `takeIf` 는 주어진 조건을 만족하면 그 값이, 그렇지 않으면 null 이 반환된다.
- `takeUnless` 는 주어진 조건을 만족하지 않으면 그 값이, 그렇지 않으면 null 이 반환된다.

```kotlin
fun getNumberOrNull(): Int? {
	return if (number <= 0) {
		null
	} else {
		number
	}
}
// 위와 같은 코드를 아래와 같이 바꿀 수 있다.
fun getNumberOrNullV2(): Int? {
	return number.takeIf { it > 0 }
}
```

# 20강. 코틀린의 scope function





---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_최태현
  - 자바_개발자를_위한_코틀린_입문
  - Kotlin
---
# 15강. 코틀린에서 배열과 컬렉션을 다루는 방법

## 1. 배열

- 별로 쓰지 않지만 문법을 알고있자.

```java
int[] array = {100, 200};

for (int i = 0; i < array.length; i++) {
	System.out.println("%s %s", i, array[i]);
}
```

```kotlin
fun main() {  
    val array = arrayOf(100, 200)  
  
    for (i in array.indices) {  
        println("${i} ${array[i]}")  
    }
    for ((idx, value) in array.withIndex()) {  
        println("$idx $value")  
    }
}
```

## 2. 코틀린에서의 Collection - List, Set, Map

- 컬렉션을 만들어줄 때 불변인지, 가변인지를 설정해야 한다.
- Kotlin 에서의 컬렉션 계층 구조를 보면 Java 와 다르게 Mutable 인터페이스가 있다.

![[자바 개발자를 위한 코틀린 입문 - Collection 계층구조.png|600]]

- 가변 (Mutable) 컬렉션
	- 컬렉션에 element 를 추가, 삭제할 수 있다.
- 불변 컬렉션
	- 컬렉션에 element 를 추가, 삭제할 수 없다.

- 불변 컬렉션이라 하더라도 Reference Type 인 Element 의 필드는 바꿀 수 있다.

### List

```java
final List<Integer> numbers = Arrays.asList(100, 200);

System.out.println(numbers.get(0));
for (int number : numbers) {
	System.out.prntln(number);
}
for (int i = 0; i < numbers.size9); i++) {
	System.out.println(numbers.get(i));
}
```

```kotlin
val numbers = listOf(100, 200)   // 불변 리스트
val emptyList = emptyList<Int>() // numbers 와 달리 타입을 추론할 수 없기 때문에 적어줘야 한다.

println(numbers[0])
for (number in numbers) {
	println(number)
}
for ((idx, value) in numbers.withIndex()) {
	println(value)
}

val mutableNumbers = mutableListOf(100, 200) // 가변 리스트 (기본 구현체는 ArrayList, 기타 사용법은 Java 와 동일)
mutableNumbers.add(400)
```

> [!tip]
> 우선 불변 리스트를 만들고, 꼭 필요한 경우 가변 리스트로 바꾸자!

### Set

집합은 List 와 다르게 순서가 없고, 같은 element 는 하나만 존재할 수 있다.

```kotlin
val numbers = setOf(100, 200) // 불변
for (number in numbers) {  
    println(number)  
}  
for ((index, number) in numbers.withIndex()) {  
    println(number)  
}

val mutableNumbers = mutableSetOf(100, 200) // 가변 Set (기본 구현체는 LinkedHashSet)
```

### Map

```java
Map<Integer, String> oldMap = new HashMap<>();
oldMap.put(1, "MONDAY");
oldMap.put(2, "TUESDAY");

Map.of(1, "MONDAY", 2, "TUESDAY");

for (int key : map.keySet()) {
	System.out.println(key);
	System.out.println(map.get(key));
}
for (Map.Entry<Integer, String> entry : map.entrySet()) {
	System.out.println(entry.getKey());
	System.out.println(entry.getValue());
}
```

```kotlin
val oldMap = mutableMapOf<Int, String>() // 가변
oldMap.put(1, "MONDAY")  
oldMap[2] = "TUESDAY"  
  
val newMap = mapOf(1 to "MONDAY", 2 to "TUESDAY") // 불변

for (key in oldMap.keys) {  
    println(key)  
    println(oldMap[key])  
}  
for ((key, value) in oldMap.entries) {  
    println(key)  
    println(value)  
}
```

## 3. 컬렉션의 null 가능성, Java 와 함께 사용하기

- ? 위치에 따라 null 가능성 의미가 달라지므로 차이를 잘 이해해야 한다.

```kotlin
List<Int?>  : 리스트에 null 이 들어갈 수 있지만, 리스트는 절대 null 이 아님
List<Int>?  : 리스트에 null 이 들어갈 수 없지만, 리스트는 null 일 수 있음
List<Int?>? : 리스트에 null 이 들어갈 수도 있고, 리스트가 null 일 수도 있음
```

- Java 는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않는다.
	- 그래서 Kotlin 의 읽기 전용 컬렉션에 Java 가 값을 추가한 후, 다시 Kotlin 에 돌려주면 Kotlin 입장에서는 이건 읽기 전용 컬렉션이기 때문에 오류가 난다.
- Java 는 nullable 타입과 non-nullable 타입을 구분하지 않는다.
	- 그래서 Kotlin 의 null 이 들어갈 수 없는 컬렉션에 Java 가 값을 추가한 후, 다시 Kotlin 에 돌려주면 Kotlin 입장에서는 이건 읽기 전용 컬렉션이기 때문에 오류가 난다.
- 그렇기 때문에 Kotlin 쪽의 컬렉션이 Java 에서 호출되면 컬렉션 내용이 변할 수 있음을 감안해야 한다.
- Kotlin 쪽에서 `Collections.unmodifableXXX()`를 활용하면 변경 자체는 막을 수는 있다.

- Kotlin 에서 Java 컬렉션을 가져다 사용할 때 플랫폼 타입을 주의해야 한다.
	- Java 에서 `List<Integer>` 를 Kotlin 에게 보내면 Kotlin 입장에서는 `List<Int?>`, `List<Int>?`, `List<Int?>?` 중 어떤것인지 알 수가 없다.
- 이럴때는 Java 코드를 보며, 맥락을 확인하고 java 코드를 가져오는 지점을 wrapping 하며 영향 범위를 최소화하는 것이 좋다.

# 16강. 코틀린에서 다양한 함수를 다루는 방법

## 1. 확장 함수

- 기존 Java 코드 위에 자연스럽게 코틀린 코드를 추가할 수는 없을까?
- Java 로 만들어진 라이브러리를 유지보수, 확장할 때 Kotlin 코드를 덧붙이고 싶다.
- 어떤 클래스 안에 있는 메소드처럼 호출할 수 있지만, 함수는 밖에 만들 수 있게 하자.
	- 함수의 코드 자체는 클래스 밖에 있는데, 마치 클래스 안에 있는 멤버함수처럼 호출해서 쓰는 것이다.
	- 그것이 바로 확장 함수이다.

- 아래 함수에서는 String 클래스를 확장한다.
- 그래서 `String.` 을 추가할 함수인 `lastChar` 앞에 붙였다.
- 함수 안에서는 `this` 를 통해 인스턴스에 접근 가능하다.

```kotlin
fun String.lastChar() : Char {  
    return this[this.length - 1]  
}
```

```
fun 확장하려는클래스.함수이름(파라미터): 리턴타입 {
	// this 를 이용해 실제 클래스 안의 값에 접근
}
```

- 이때 `this` 는 수신객체라 부른다.
- 그리고 확장하려는 클래스는 수신객체 타입이라 부른다.

- 쓸때는 아래와 같이 쓴다.

```kotlin
fun main() {  
    val str = "ABC"  
    str.lastChar()  
}
```

> [!important]
> 확장함수는 클래스에 있는 private 또는 protected 멤버를 가져올 수 없다.

> [!important]
> 멤버함수와 확장함수의 시그니처가 같다면 멤버함수가 우선적으로 호출된다.

- 확장함수를 만들었지만, 다른 기능의 똑같은 멤버함수가 생기면 오류가 발생할 수 있다.

> [!important]
> 확장함수가 오버로딩 된 경우, 해당 변수의 현재 타입, 즉, 정적인 타입에 의해 어떤 확장함수가 호출될지 결정된다.


- 그럼 Java 에서 Kotlin 확장함수를 가져다 사용할 수 있을까?
- Java 에서는 Kotlin 에 존재하는 확장함수를 정적 메소드를 부르는 것처럼 사용 가능하다.

```java
public statc void main(String[] args) {
	StringUtilsKt.lastChar("ABC");
}
```

- 확장함수라는 개념은 **확장프로퍼티**와도 연결된다.
- 확장 프로퍼티의 원리는 확장함수 + custom getter 와 동일하다.

```kotlin
fun String.lastChar(): Char {     // 함수
	return this[this.length - 1]
}

val String.lastChar: Char         // 프로퍼티
	get() = this[this.length - 1]
```

## 2. infix 함수


## 3. inline 함수



## 4. 지역함수






# 17강. 코틀린에서 람다를 다루는 방법





# 18강. 코틀린에서 컬렉션을 함수형으로 다루는 방법







---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_최태현
  - 자바_개발자를_위한_코틀린_입문
  - Kotlin
---
# 1강. 코틀린에서 변수를 다루는 방법

## 1. 변수 선언 키워드 - var 과 val 의 차이점

### Java 코드

```java
long number1 = 10L; // (1)  
final long number2 = 10L; // (2)  
  
Long number3 = 1_000L; // (3)  
Person person = new Person("최태현"); // (4)
```

- java 에서 long 과 final long 의 차이
	- 이 변수는 가변인가 불변인가

### Kotlin 코드

```kotlin
var number1 = 10L // 가변변수
val number2 = 10L // 불변변수

var number3: Long = 10L // 타입작성 안해도 된다. 하고 싶다면 콜론 띄고 타입을 쓰면 된다.
val number4: Long = 10L // 타입작성 안해도 된다. 하고 싶다면 콜론 띄고 타입을 쓰면 된다.

var number5 // 에러. 초기값을 넣지 않으면 값을 추론할 수 없기 때문에 에러가 난다.
var number6: Long // 타입을 넣어주면 에러가 나지 않는다.
println(number6) // 에러. 초기값을 넣지 않았기 때문에 에러가 난다.

val number7 // 에러. 초기값을 넣지 않으면 값을 추론할 수 없기 때문에 에러가 난다.
val number8: Long // 타입을 넣어주면 에러가 나지 않는다.
println(number8) // 에러. 초기값을 넣지 않았기 때문에 에러가 난다.
```

- 모든 변수는 var 또는 val 을 붙여 주어야 한다.
	- var : 변경 가능
	- val : 변경 불가능

- 코틀린에서는 타입을 컴파일러가 자동으로 추론해준다.
- 초기값을 지정해주지 않는 경우엔 타입을 명시해줘야 한다.

- val 컬렉션에 element 를 추가할 수 있다.
- Java 에서는 `final List<Integer> list = new ArrrayList<>()` 일 경우 `final` 이 붙어도 list 안에 element 를 넣을 수 있는다.
- kotlin 에서도 똑같이 val 컬렉션에 element 을 넣을 수 있다.

> [!tip]
> 모든 변수는 우선 val 로 만들고 꼭 필요한 경우 var 로 변경한다.

## 2. Kotlin 에서의 Primitive Type

### Java 코드

```java
long number1 = 10L; // (1)  
Long number3 = 1_000L; // (3)  
```

- long 은 primitive type
- Long 은 reference type
- 보통 연산할 때 성능향상을 위해서 long 을 쓰라고 함

### Kotlin 코드

```kotlin
var number1: Long = 10L
var number3: Long = 1_000L
```

- Kotlin 에서는 모두 Long 이다.
- 그럼 성능이 떨어지지 않을까?

> [!quote]
> 숫자, 문자, boolean 과 같은 몇몇 타입은 내부적으로 특별한 표현을 갖는다.
> 이 타입들은 실행시에 Primitie Value 로 표현되지만, 코드에서는 평범한 클래스 처럼 보인다.

- 즉, Long 타입 하나로 합쳐져 있지만, 만약 연산을 하게 될 경우 Kotlin 이 알아서 내부적으로 primitive type 으로 바꿔서 처리해준다.
- 즉, 프로그래머가 boxing / unboxing 을 고려하지 않아도 되도록 알아서 처리해준다는 뜻이다.

> [!tip]
> IntelliJ 에서 Tools -> Kotlin -> Show Kotlin Bytecode -> Decompile 를 누르면 Kotlin 코드를 Java 코드로 바꿔서 볼 수 있다.

## 3. Kotlin 에서의 nullable 변수

### Java 코드

```java
Long number3 = null; // (3)  
```

- 위 코드에 null 이 들어갈 수도 있다.

### Kotlin 코드

```kotlin
var number3 = null // 에러. 모든 변수에는 null 이 들어갈 수 없게 설계해놓았다.
var number4: Long? = 1_000L 
number4 = null // 오류가 나지 않는다.
```

- 기본적으로 Kotlin 에서 모든 변수는 null 이 들어갈 수 없다.
- null 들어갈 수 있게 설정하고 싶다면 "타입?" 를 사용해야 한다.

## 4. Kotlin 에서의 객체 인스턴스화

### Java 코드

```java
Person person = new Person("최태현"); // (4)
```

```java
public class Person {  
  
  private final String name;  
  
  public Person(String name) {  
    this.name = name;  
  }  
  
  public String getName() {  
    return name;  
  }  
 
}
```

### Kotlin 코드

```kotlin
var person = Person("최태현")
```

- Kotlin 에서는 객체를 생성할 때 new 를 쓰지 않는다.

# 2강. 코틀린에서 null 을 다루는 방법

## 1. Kotlin 에서의 null 체크

자바 코드를 그대로 코틀린 코드로 옮겨보자.

### 예제 1

```java
public boolean startsWithA1(String str) {  
	if (str == null) {  
		throw new IllegalArgumentException("null이 들어왔습니다");  
	}  
	return str.startsWith("A");  
}
```

- 파라미터 str 에 null 이 들어갈 수 있으므로 물음표를 붙여주었다.

```kotlin
fun startWithA1(str: String?): Boolean {  
	if (str == null) {  
        throw IllegalArgumentException("null이 들어왔습니다")  
    }  
    return str.startsWith("A")  
}
```

### 예제 2

```java
public Boolean startsWithA2(String str) {  
	if (str == null) {  
		return null;  
	}  
	return str.startsWith("A");  
}
```

- 파라미터 뿐만 아니라 리턴값에도 null 이 들어갈 수 있으므로 물음표를 붙여주었다.

```kotlin
fun startWithA2(str: String?): Boolean? {  
    if (str == null) {  
        return null  
    }  
    return str.startsWith("A")  
}
```

### 예제 3

```java
public boolean startsWithA3(String str) {  
	if (str == null) {  
		return false;  
	}  
	return str.startsWith("A");  
}
```

- 아래 Kotlin 코드에서 null 체크 없이 바로 `startsWith` 를 쓰면 에러가 뜬다.
- 파라미터 str 에 물음표가 붙은 것을 컴파일러가 보고 null 체크가 없는 것을 확인 후 에러를 보내는 것이다.

```kotlin
fun startWithA3(str: String?): Boolean {  
    if (str == null) {  
        return false  
    }  
    return str.startsWith("A")
}
```

- 따라서 아래와 같이 파라미터에 물음표가 없을 경우에는 바로 `startWith` 를 써도 된다.

```kotlin
fun startsWithA(str: String): Boolean {
	return str.starsWith("A")
}
```

> [!important]
> 즉, Kotlin 에서는 null 이 가능한 타입을 완전히 다르게 취급한다.
> 한번 null 검사를 하면 non-null 임을 컴파일러가 알 수 있다.

- 그럼 null 이 가능한 타입만을 위한 기능은 없을까?
- Safe Call 과 Elvis 연산자가 있다.

## 2. Safe Call 과 Elvis 연산자

### Safe Call

- null 이 아니면 실행하고, null 이면 실행하지 않는다 (결과값도 null 이 된다)

```kotlin
val str: String? = "ABC"
str.length // 불가능. 컴파일러에서 오류를 보낸다.
str?.length // 가능
```

### Elvis 연산자

- 앞의 연산 결과가 null 이면 뒤의 연산을 사용

```kotlin
val str: String? = "ABC"
str?.length ?: 0 // 만약 str 이 null 이면 str.length 는 0 이 된다
```

### Safe Call 과 Elvis 연산자를 이용한 앞 예제 수정

```kotlin
fun startWithA1(str: String?): Boolean {  
    return str?.startsWith("A")  
        ?: throw IllegalArgumentException("null이 들어왔습니다")  
}  
```

```kotlin
fun startWithA2(str: String?): Boolean? {  
    return str?.startsWith("A")  
}  
```

```kotlin
fun startWithA3(str: String?): Boolean {  
    return str?.startsWith("A") ?: false  
}
```

### Elvis 연산을 이용한 early return

- Elvis 연산은 early return 에도 사용할 수 있다.

```java
public long calculate(Long number) {
	if (number == null) {
		return 0;
	}
	// 다음 로직
}
```

```kotlin
fun calculate(number: Long?): Long {
	number ?: return 0
	// 다음 로직
}
```

## 3. null 아님 단언!!

- nullable type 이지만, 아무리 생각해도 null 이 될 수 없는 경우
- 느낌표 두개를 연속해서 쓰면 된다.
- 만약 null 이 들어간 경우에는 컴파일 타임 에러는 안나지만 런타임 에러(NullPointException)이 난다.
- 그러니 null 이 아닌게 확실한 경우에만 쓰자.

```kotlin
fun startsWithA1(str: String?): Boolean {  
    return str!!.startsWith("A")  
}
```

## 4. 플랫폼 타입

- Kotlin 에서 Java 코드를 가져다 사용할 떄 어떻게 처리될까?

```java
import org.jetbrains.annotations.Nullable;  
  
public class Person {  
  
  private final String name;  
  
  public Person(String name) {  
    this.name = name;  
  }  
  
  @Nullable
  public String getName() {  
    return name;  
  }  
  
}
```

```kotlin
val person = Person("공부하는 개발자")  
startsWithA(person.name) // @Nullable 이 있어서 오류가 난다. 만약 @Nullable 을 @NotNull 로 바꾸면 오류가 나지 않는다.
```

- 코틀린 코드에서 Java 코드를 가져다 쓸 때 `@Nullable`, `@NotNull` 과 같은 Annotation 정보를 코틀린이 이해한다.

- 아래와 같은 패키지에 있는 null 관련 Annotation 을 사용하면 코틀린에서 이것을 인식하고 이해해서 활용할 수 있다.
	- javax.annotation 패키지
	- android.support.annotation 패키지
	- org.jetbrains.annotation 패키지

### 그런데 만약 @Nullable 이 없다면?

- Kotlin 에서는 이 값이 nullable 인지 non-nullable 인 지 알 수가 없다.
- 그래서 이런 타입을 플랫폼타입 이라고 부른다.
	- 코틀린이 null 관련 정보를 알 수 없는 타입인 것이다.
- 이런 타입은 Runtime 시 Exception 이 날 수 있다.
- 그래서 Kotlin 에서 Java 코드를 사용할 때 플랫폼 타입 사용에 유의해야 한다.
- Java 코드를 읽으며 null 가능성을 확인하거나 Kotlin 으로 Wrapping 해야 한다.

# 3강. 코틀린에서 Type 을 다루는 방법





# 4강. 코틀린에서 연산자를 다루는 방법











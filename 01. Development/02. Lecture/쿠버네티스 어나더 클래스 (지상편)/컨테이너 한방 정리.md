---
tags:
  - 학습정리
  - 온라인_강의
  - 인프런
  - 강사_일프로
  - Kubernetes
  - Container
  - Linux
  - DevOps
---
# Linux OS, Container, Container Orchestration

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 1.png]]

## Linux OS

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 2.png]]

- 최초의 OS 로 UNIX 가 있었다.
- 아직도 기업에서 쓰고 있긴 하지만, 유료라서 금방 잊혀졌다.

- Linux 가 새로 나왔다.
- UNIX 와 달리 무료라서, 이를 기반으로 많은 배포판들이 만들어졌고, 만들어지고 있다.

- 이 중에서 가장 중요한 배포판은 두가지 이다.
	- debian
	- Red Hat
- debian linux 는 커뮤니티용이기 때문에 무료
- redhat linux 는 redhat 이라는 기업에서 만들었고 유료

- debian 계열의 대표 배포판은 ubuntu 가 있다.
- debian 에 비해 사용자 편의 기능이 더 많다.
- linux 에서는 최초로 Windows 처럼 UI 를 제공했다.

- IBM 인수 전 redhat 에서 linux 배포판이 만들어지는 순서
	1. fedora linux 
		- 새로운 기능을 개발하는 배포판. 무료
	2. Red Hat Enterprise Linux (RHEL, 렐)
		- 새로운 기능이 안정화 되면 이름을 위와 같이 바꿔서 릴리즈
		- 기업들이 이걸 설치하면 유지보수 비용을 내야함. 유료
	3. CentOS
		- RHEL 을 복사해서 만
		- RHEL 과 똑같이 안정화 버전이지만 무료
		- 그래서 유지보수를 직접 할 여력이 되는 기업이 쓴다.
		- 개발비용을 낮추기 위해 개발환경까지는 CentOS 를 쓰고, 운영환경만 RHEL 을 쓰기도 한다.

- 이렇게 기업에서는 redhat 계열을 많이 쓰고, 개인 학습용이나 클라우드에서는 ubuntu 를 많이 쓴다.

- 하지만 이제 CentOS8 은 2021년 지원 종료, CentOS7 은 2024년 지원 종료된다.
- 이유
	1. 시장 점유율이 ubuntu 가 압도적
		- ubuntu 47%
		- CentOS 19%
		- debian 17%
		- RHEL 2% (기업 배포판 1위)
	2. IBM 이 redhat 인수 후 전략 변경
		- CentOS 의 점유율을 RHEL 로 당기려 함

- IBM 인수 후 redhat 에서 linux 배포판이 만들어지는 순서
	1. fedora linux
		- 새로운 기능 개발하는 배포판. 무료
	2. Centos Stream
		- 새로 개발된 기능들을 테스트하는 배포판. 무료
		- 이 배포판에서는 바이너리 호환성 보장이 안될 수 있다고 말함
	3. Red Hat Enterprise Linux (RHEL, 렐)
		- 새로운 기능이 안정하된 배포판. 유료

- 따라서 기존에 CentOS 를 쓰던 기업들에게는 4가지 선택지가 있다.
	1. RHEL 로 넘어간다.
	2. CentOS 를 기술 지원해주는 기업의 도움을 받으며 그대로 CentOS 를 쓴다.
	3. Ubuntu 와 같은 타 OS 로 마이그레이션 스크립트를 이용하여 넘어간다.
	4. RHEL 를 복제하여 만드는 무료 배포판으로 넘어간다.
		- 기존 CentOS 와 같이 무료 배포판을 만드는 프로젝트가 있다.
		-  ex) rocky linux, alma linux 

- 여기서는 4번을 선택해 rocky linux 로 실습을 한다.
	- centOS 는 강사가 가장 잘쓰는 리눅스 배포판
	- 따라서 가장 잘 쓸 수 있는 배포판을 이용하여 강의를 한다.
	- rocky linux 를 선택한 이유는 훨씬 많이 사용되기 때문이다.
		- [Google Trend](https://trends.google.com/trends/explore?date=today%205-y&q=rocky%20linux,alma%20linux&hl=en)
		- Github Stars 와 forks 개수
	
## Container

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 3.png]]

- 리눅스는 발전하면서 많은 코어 기술을 개발했다.
- 그중 하나는 격리 기술이다.
	- chroot : 유저, 파일, 네트워크 격리
	- cgroup : App 마다 cpu, memory 를 할당
	- namespace : 프로세스를 격리시켜주는 기술
- 이런 기술들이 쌓이며 각각의 App 을 독립적인 환경에서 실행시킬 수 있게 되었다.

- 이런 기술들을 집약하여 최초의 컨테이너인 LXC(Linux Container)가 만들어졌다.
- 그리고 이 기술을 기반으로 Docker 가 만들어졌다.
	- LXC 에 비해 쓰기 쉽다는 것이 장점

- Docker 가 나온 후 rkt 라는 보안이 강화된 컨테이너가 만들어졌다.
- 처음에 Docker 는 root 권한으로 설치 및 실행해야 했는데 그걸 보완하였었다.
- 하지만 현재는 rootless 설치모드가 생겨서 보안이 강화되었다.

- (rkt 의 태생을 보면) linux 의 여러 배포판 중에 컨테이너 전용 linux 인 Core OS 가 있고 rkt 는 이 OS 에 대한 대표 컨테이너였다.
- 그런데 이 OS 가 redhat 으로 인수되면서 fedora coreOS 로 이름이 바뀌었다.
- 그런데 redhat 이 밀고 있는 컨테이너가 cri-o(크라이오)기 때문에 rkt 의 입지가 점점 줄어들고 있다.

## Container Orchestration

### Container Orchestration 이 가지는 장점

#### Container 만으로 배포하는 과정

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 4.png]]

- 위 과정을 사용자가 차레대로 전부 해야한다.

#### Container Orchestration 으로 배포하는 과정

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 5.png]]

- 사용자는 단 한번 지시만 하면 된다.

### Container Orchestration 의 히스토리

- Docker 가 나온 이후 kubernetes 를 비롯한 다양한 Container Orchestration 이 쏟아져나왔다.
- 이 제품들 간에 개념, 용어, 기술이 서로 다 다르다.
- 하지만 이제 쿠버네티스만 알면 된다.
	- [사용도가 압도적이기 때문](https://trends.google.com/trends/explore?date=today%205-y&q=%2Fg%2F11b7lxp79d,docker%20swarm,hashicorp%20nomad,%2Fm%2F012n8tpr&hl=en)

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 6.png|]]

- Container Orchestration 은 쿠버네티스가 표준으로 되가고 있고, 이제 Container 간의 싸움이 시작된다.
- 초반에는 docker 가 우세했다.
	- 보안이 약하다는 것은 시간이 충분히 지나면 보완될 것이라는 기대가 있었고 실제로 보완이 되었었으니까.
- 하지만 k8s 에서 docker 가 빠진다는 이야기가 계속 돌며 docker 의 위세가 조금씩 꺾이기 시작하였다.
- 이유는 docker 가 쿠버네티스 인터페이스와 잘 맞지 않아서 그렇다.

- 처음에는 docker 처럼 사용자들이 쓰기 편한 컨테이너가 주목되었다.
	- 그래서 docker 를 메인으로 쿠버네티스가 만들어졌다.
- 그런데 이제 점점 컨테이너와 컨테이너 오케스트레이션이 함께 움직이며 컨테이너를 직접 다룰 일이 점점 줄어들었다.
- 왜냐하면 kubernetes 가 컨테이너를 알아서 조작하기 때문이다.
- 그래서 이제 컨테이너는 k8s 와 인터페이스가 잘 맞는지가 중요해졌다.

- 참고로 docker 가 mirantis 라는 회사에 인수가 된 이후부터 쿠버네티스 인터페이스에 잘 맞추려 하고 있기 때문에 쿠버네티스에서 docker 가 빠지지는 않게 된다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 7.png]]

- 그 이후에 나온 컨테이너가 containerd 와 cri-o 이다.

- containerd 는 docker 에 컨테이너를 만들어주는 기능이 분리된 것이다.
	- docker 에는 컨테이너 기능뿐만 아니라 많은 기능이 담겨있다.
	- 그 엔진에서 containerd 프로젝트만 분리되어 나온 것이다. 
- cri-o 는 redhat 에서 만든 컨테이너이다.

- 두 컨테이너 모두 CNCF 에 기부되었다.
- CNCF 는 클라우드 분야의 표준을 관장하는 곳이다.
- 여기에서 관리하는 프로젝트들은 기술 성숙도에 따라 Incubating project, Graduated project 로 불린다.
- Graduated project 는 충분히 기술이 성숙되었을 때 주어진다.
	- 따라서 앞으로 쿨라우드 기술을 고를 때 CNCF 를 졸업했다고 하면 그냥 믿고 쓰면 된다.
- containerd 는 이미 Graduated project
- cri-o 는 아직 Incubating project 이지만 곧 Graduated project 가 될 예정이다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 8.png]]

- 쿠버네티스도 CNCF 에 기부되었고 가장 첫번째로 졸업한(Graduated) 프로젝트이다.
- 그리고 기업들은 쿠버네티스를 이용하여 자신의 제품들을 만들기 시작하였다.
	- OPENSHIFT, RANcHER, VMware Tanzu 등
- 이는 기업 관리형이라 하여, 기업이 쿠버네티스를 관리하는데 좀 더 편한 기능들을 제공해주는 제품이다.
	- 왜 이런제품이 있느냐면, 쿠버네티스는 알면 알수록 해야할 것이 많다. 그리고 작은 기업에서는 이를 전부 다루기 힘들기 때문이다.
	- 이런 제품을 설치하면 쿠버네티스 외에 모니터링, 로깅, 배포 툴까지 한 패키지로 설치해준다.
	- 문제가 생기면 기술지원도 해주기 때문에 작은 기업에서는 쓸만하다.
- 이런 제품들은 기업에서 자체 서버실에 프라이빗하게 쿠버네티스를 주로 쓰고 싶을 때 사용한다.
- 그렇지 않고, 퍼블릭으로 쿠버네티스를 쓰고 싶으면 클라우드 서비스로 쿠버네티스를 사용한다.

# Container Runtime

Container 와 Container Orchestration 의 기반 기술에 대해 알아보자.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 9.png]]

## Container 기반기술

### Linux

- 리눅스에서는 chroot, namespace, cgroup 을 기반으로 하고 있다.

## Container Runtime

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 11.png|700]]

- 컨테이너 런티임은 High Level 과 Low Level 로 나뉘어 진다.

- LXC 는 커널레벨 기술을 가지고 만들어진 Low Level 컨테이너 런타임이다.
- 그 다음으로 docker 가 LXC 를 기반으로 libcontainer 라는 Low Level 컨테이너 런타임을 만들었다.

- libcontainer 를 이용하여 사용자 친화적으로 만든 High Level 컨테이너 런타임이 바로 Docker 이다.
- Docker 는 컨테이너 생성 기술 외에 많은 기능들이 들어가 있다.
	- API 기능, 로그 기능, 스토리지, 네트워크 등
- 그래서 사용자 편의가 좋다고 하는 것이다.

- 여기서 컨테이너 생성 역할은 containerd 가 가지고 있다.
- containerd 는 Low Level 인 libcontainer 를 이용하여 컨테이너를 생성해준다.
- 쿠버네티스 입장에서는 주로 컨테이너를 생성하는 기능만 쓰기 때문에 이 부가적인 기능들이 좀 과해 보일 수 있다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 10.png|700]]

- 다시 돌아가서...
- docker 는 LXC 의 기술을 이용하지만 이 둘은 큰 차이가 있다.
- 각각 컨테이너를 만들어 주긴 하지만 그 목적이 다르기 때문이다.
- docker 는 APP 들을 독립적인 환경에서 띄우려고 사용한다.
- LXC 는 운영체제를 컨테이너 가상화로 나누기 위한 목적이다.
	- 이걸 쓰면, 내 linux 호스트 위에 centOS 나 ubuntu 를 Guest OS 로 또 띄울 수 있다.
	- 기존에 VM 기술로 했던 것을 컨테이너 기술로 하는 것이다.

- 앞서 말했듯 rkt 라는 컨테이너 런타임도 있지만 사용자에게 잊혀지고 있다.
- 왜냐하면 low level 런타임이기 때문에 쓰기가 어렵기 때문이다.



- 이제 쿠버네티스가 컨테이너 런타임을 어떻게 쓰는지 보자.
- 쿠버네티스에는 kube-apiserver 와 kubelet 이라는 컴포넌트가 있다.
- 그리고 쿠버네티스에 컨테이너 하나를 생성하는 명령은 없고, Pod 를 만들라는 명령은 있는데 이 Pod 안에 컨테이너를 하나 이상 명시할 수 있다.
- 그래서 일단 컨테이너 두 개를 한 Pod 에 만들라는 명령을 보내면 kube-apiserver 는 쿠버네티스로 보내지는 모든 API 를 받는다.
- 현재 받은 API 가 Pod 생성에 관련된 내용이니까 Pod 생성을 담당하는 kubelet 에게 요청을 전달한다.
- kubelet 은 요청을 확인한 후 Pod 안에 Conatiner 가 두개라는 것을 확인하고, Container Runtime 에게 Container 생성 명령을 날린다.
	- 여기서는 컨테이너가 두개이기 때문에 컨테이너 생성 요청을 두번 보낸다.
- 그러면 컨테이너 런타임은 요청 받은대로 두 개의 컨테이너를 만들어준다.
- docker 를 컨테이너라 주로 부르지만 정확히는 컨테이너 런타임이라고 불러야 맞는 것이다.
- 컨테이너를 생성해주는 역할을 하는 것이 컨테이너 런타임이고, 컨테이너는 생성물이다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 12.png|700]]


- 이제 kubelet 과 Container Runtime 에 대해 이야기해보자.
- 여기서부터가 쿠버네티스와 인터페이스에 대한 내용이다.
- kubelet 은 컨테이너 런타임이 받을 수 있는 형태의 API 를 호출한다.
- 실제로 kubelet 소스를 보면 case 문으로 docker 인지 rkt 인지 판단하는 로직이 있다.
- docker 랑 rkt 에 호출 API 들을 모아둔 패키지들도 있어서 컨테이너 런타임에 맞춤형 API 를 날려준다.
- 쿠버네티스 1.0 버전은 이렇게 시작했다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 13.png|300]]

- 하지만 시간이 지나며 docker 에서 containerd 가 따로 분리되서 나왔다.
	- 지금 쿠버네티스를 설치할 때 containerd 를 제일 많이 쓴다.
- 그리고 점점 컨테이너 런타임이 늘어나게 되었다.
- 쿠버네티스는 런타임이 늘어날 때마다 kubelet 소스를 건드려야 되는 구조.
- 그래서 쿠버네티스는 1.5 버전 부터는 interface 를 추가한다.
- 그리고 구현부를 따로 빼는데 이를 CRI 라고 해서 Container Runtime Interface 라고 부른다.
- kubelet 에 인터페이스 규격을 정하고 이 규격에 맞게 구현부를 만들었고, 이 구현부에서 각각에 컨테이너 런타임을 호출한다.
	- 구현부는 쿠버네티스 프로젝트에 있는 것이고, 이 프로젝트가 오픈소스니까 각각 컨테이너 런타임 측(docker, rkt 등)에서 쿠버네티스 프로젝트의 소스를 contribution 하는 형태이다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 14.png|300]]

- 쿠버네티스에서 docker 를 더이상 지원 안한다는 이야기가 있었다.
- 이게 1.0 버전 부터 썼던 로직을 1.20 버전부터는 없애겠다는 것이고, 1.5 버전 부터 인터페이스 규격으로 정한 로직을 쓰겠다는 말이었다.
- 그런데 docker 를 아예 못쓴다고 사람들이 오해를 했었다.
- 그래서 쿠버네티스에서는 CRI 규격에 맞춰진 dockershim 이 있으니까 docker 를 그대로 쓸 수 있다고 답변하였다.

- 그런데 이게 1.23 버전까지만 유지를 하고 1.24 버전부터는 dockershim 이 없어진다는 이야기가 나왔다.
- 그래서 또 사람들이 쿠버네티스에서 도커를 못쓴다고 생각을 했다.
	- 이떄 많은 사람들이 containerd 로 전환하기 시작했다.
- 이게 CRI 구현부가 없어지는게 아니라 dockershim 만 빼겠다는 내용인데, 왜 그런 상황이 생겼냐면,
	- 1.5 버전부터 23 버전까지 dockershim 이 유지되면서 dockershim 관리가 잘 안됐고, 버그도 많았다고 한다.
	- 이 docker 가 수익 모델이 별로 없고, 그래서 인수도 된거니 관리하기가 힘들었던 배경이 좀 느껴진다.
- 그리고 docker 유료화 얘기를 들은 사람들이 있을텐데, 이건 컨테이너 런타임으로서의 docker 가 유료화가 되는 것이 아니라, 윈도우로 설치해서 관리하는 docker desktop 이 유료화 하겠다는 것이었다.
- 그래서 컨테이너 런타임에 docker는 그대로 사용해도 된다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 15.png|600]]

- 그리고 kubelet 에 다음 단계가 있는데, 이 docker 부분만 먼저 설명을 하면
- mirantis 가 docker 를 인수하고, cri-dockerd 라는 어댑터를 만들었는데 내용적으로는 dockershim 을 밖으로 뺀것이다.
- 이것을 통해서 docker 를 다시 지원할 수 있게 했다.
- 그래서 1.24 버전부터는 또 docker 가 계속 지원이 된다.
- 다만 이름이 좀 바뀌어서 cri-dockerd 를 미란티스 컨테이너 런타임이라 부른다.
- 이렇게 우여곡절이 있는동안 containerd 나 cri-o 에게 런타임을 많이 내줬다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 16.png|300]]

- 컨테이너 표준에 대한 이야기를 해보자.
- 이런 이슈들 때문에 컨테이너 런타임을 변경해야 되나 싶을 때 고민되는 부분이 이 container image 이다.
- 만약 docker 에서 containerd 로 런타임을 바꾸게 되면 기존에 쓰던 이미지를 다시 만들어야 할까?
- 아니다. docker 도 결국 containerd 를 쓰기 때문에 만들어지는 컨테이너는 같다.

- 하지만 별개로 컨테이너 종류가 점점 많어지면서 표준의 필요성을 느끼게 됐고, 그래서 만들어진 단체가 OCI 이다.
- 여기서는 컨테이너 런타임이 컨테이너를 만들 때 지켜야되는 표준 규약들을 관리한다.
- 그래서 이 규약을 지켜서 컨테이너를 만들면 런타임 끼리 서로 공유해서 쓸 수 있게 된다.
- 이때 docker 에서는 이 OCI 규격을 맞추기 위해서 Low Level 에 runC 를 만들었고, containerd 에서도 이것을 쓰도록 변경하였다.
- 이 runC 가 기존에 libcontainer 와 다른 점은 이제 LXC 를 이용하지 않고 kernel 레벨에 가상화 기술을 쓴다는 것이다.
- rkt 도 마찬가지로 oci 표준을 따르고 있다.
- 그렇기 때문에 docker 에서 돌던 컨테이너 이미지를 rkt 에서도 사용할 수 있다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 17.png|900]]

- 현재까지는 아래 부분이 CRI 구간이다.
- 내부간 통신은 grpc 라는 걸로 하는데 여전히 쿠버네티스 입장에서는 아쉬운 점이 있다.
- 컨테이너 런타임의 기술 개발과 쿠버네티스의 기술 개발은 서로 별개이다.
- 그런데 docker 에 새로운 기능이 생기면 쿠버네티스도 같이 패치를 해야한다.
- 여전히 이 구조상 컨테이너 런타임이 변경될 때 마다 CRI 의 구현체도 수정을 해야되니까 결국 쿠버네티스도 패치해야 하는 것이다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 18.png|300]]

- 그래서 아래와 같이 kubelet 에서 컨테이너 런타임으로 바로 받을 수 있게 구조를 바꾸었다.
- 이런 구조를 지원하기 위해서 containerd 에서는 CRI-Plugin 이라는 기능이 추가되었다.
- cri-o 는 태생부터 redhat 이 이 규격을 맞춰서 만든 런타임이다.
- 그리고 mirantis 컨테이너 런타임도 이것을 따르려고 cri-dockerd 를 만들었던 것이다.
- 그리고 쿠버네티스에서는 1.27 버전 부터, POD 를 만들라고 했을 때 이 구조를 기본 동작으로 실행한다.
- 이 강의도 1.27 버전에 쿠버네티스를 설치하기 때문에 대략 이런 구조이겠구나 하고 생각하면 된다.

![[쿠버네티스 어나더 클래스 (지상편) - Sprint1 - 섹션 1 - 그림 19.png|400]]

- 그리고 이제는 cri-o 를 사용해도 docker 로 만든 이미지가 cri-o 에서도 잘 돌아갈 것이라 생각할 수 있다.




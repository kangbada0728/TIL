---
tags:
  - 학습정리
  - SLiPP_25차_스터디
  - Java
  - Network
  - 책_자바_IO_NIO_네트워크_프로그래밍
---
# 01. 들어기에 앞서

- NIO 에서 제공해주는 단순한 형태로 서버를 만들면 성능 극대화에 장애가 되는 부분들이 발생한다.
- 이 장에서는 그런 부분에 대해 이야기하고, 해결책에 대해 설명한다.

# 02. 효율적인 메모리 사용

```java
private void read(SelectionKey key) {
	// SelectionKey 로부터 소켓채널을 얻어온다.
	SocketChannel sc = (SocketChannel) key.channel();
	// ByteBuffer를 생성한다.
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024); // 중요
	try {
		// 요청한 클라이언트의 소켓채널로부터 데이터를 읽어들인다.
		int read = sc.read(buffer);
		info(read + " byte 를 읽었습니다.");
	} catch (IOException e) {
		try {
			sc.close();
		} catch (IOException el) {
		}
		
		removeUser(sc);
		
		info(sc.toString() + " 클라이언트가 접속을 해제했습니다.");
	}

	try {
		// 클라이언트가 보낸 메시지를 채팅방 안에 모든 사용자에게 브로드캐스트해준다.
		broadcast(buffer);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.broadcast()", e);
	}

	// 버퍼 메모리를 해제시킨다.
	clearBuffer(buffer); // 중요
}

private void clearBuffer(ByteBuffer buffer) {
	if (buffer != null) {
		buffer.clear();
		buffer = null;
	}
}
```

`중요` 라고 주석을 추가해놓은 부분을 보면 클라이언트들이 보낸 메시지를 처리할 때마다 매번 ByteBuffer 를 생성해서 사용하고, 사용이 끝나면 이 버퍼를 null 로 만들어서 가비지 컬렉션 대상으로 만든다.

이 방법은 매번 가비지를 생성하게 된다.

따라서 이 부분을 재사용하는 것이 필요하다.
14장의 메모리 매핑을 설명하는 곳에서 만든 ByteBufferPool 을 이곳에서 사용하면 효율적으로 메모리를 재사용할 수 있다.
매번 ByteBuffer 객체의 생성, 해제에 따른 가비지 생성 부담도 줄어들 것이다.

다이렉스 ByteBuffer 를 생성하는 것은 상당히 느린 작업이고, 이 문제는 ByteBufferPool 을 사용하여 해결할 수 있다.

# 03. 비효율적인 데이터 전송에 대한 고려




# 04. 동시성을 이용한 성능 극대화



# 05. 향상된 서버 만들기




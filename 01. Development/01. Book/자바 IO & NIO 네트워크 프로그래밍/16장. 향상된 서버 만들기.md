---
tags:
  - 학습정리
  - SLiPP_25차_스터디
  - Java
  - Network
  - 책_자바_IO_NIO_네트워크_프로그래밍
---
# 01. 들어기에 앞서

- NIO 에서 제공해주는 단순한 형태로 서버를 만들면 성능 극대화에 장애가 되는 부분들이 발생한다.
- 이 장에서는 그런 부분에 대해 이야기하고, 해결책에 대해 설명한다.

# 02. 효율적인 메모리 사용

```java
private void read(SelectionKey key) {
	// SelectionKey 로부터 소켓채널을 얻어온다.
	SocketChannel sc = (SocketChannel) key.channel();
	// ByteBuffer를 생성한다.
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024); // 중요
	try {
		// 요청한 클라이언트의 소켓채널로부터 데이터를 읽어들인다.
		int read = sc.read(buffer);
		info(read + " byte 를 읽었습니다.");
	} catch (IOException e) {
		try {
			sc.close();
		} catch (IOException el) {
		}
		
		removeUser(sc);
		
		info(sc.toString() + " 클라이언트가 접속을 해제했습니다.");
	}

	try {
		// 클라이언트가 보낸 메시지를 채팅방 안에 모든 사용자에게 브로드캐스트해준다.
		broadcast(buffer);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.broadcast()", e);
	}

	// 버퍼 메모리를 해제시킨다.
	clearBuffer(buffer); // 중요
}

private void clearBuffer(ByteBuffer buffer) {
	if (buffer != null) {
		buffer.clear();
		buffer = null;
	}
}
```

`중요` 라고 주석을 추가해놓은 부분을 보면 클라이언트들이 보낸 메시지를 처리할 때마다 매번 ByteBuffer 를 생성해서 사용하고, 사용이 끝나면 이 버퍼를 null 로 만들어서 가비지 컬렉션 대상으로 만든다.

이 방법은 매번 가비지를 생성하게 된다.

따라서 이 부분을 재사용하는 것이 필요하다.
14장의 메모리 매핑을 설명하는 곳에서 만든 ByteBufferPool 을 이곳에서 사용하면 효율적으로 메모리를 재사용할 수 있다.
매번 ByteBuffer 객체의 생성, 해제에 따른 가비지 생성 부담도 줄어들 것이다.

다이렉스 ByteBuffer 를 생성하는 것은 상당히 느린 작업이고, 이 문제는 ByteBufferPool 을 사용하여 해결할 수 있다.

# 03. 비효율적인 데이터 전송에 대한 고려

# 04. 동시성을 이용한 성능 극대화

- 단일 스레드를 이용하는 것 보다 멀티 스레드를 이용하는 것이 동시 접속자를 처리하기에 효율적이다.
- 어떻게 스레드를 활용하는지 보자.

## 1. Accept, Process 의 분리

```java
SelectionKey key = (SelectionKey) it.next();
if (key.isAcceptable()) {
	// 서버 소켓채널에 클라이언트가 접속을 시도한 경우
	accept(key);
} else if (key.isReadable()) {
	// 이미 연결된 클라이언트가 메시지를 보낸 경우
	read(key);
}
```

- 위 코드는 매번 클라이언트가 접속한 것인지 또는 클라이언트가 메시지를 보낸 것인지를 판단해서 처리하고 있다.
- 어떤 요청인지 검사하는 것도 성능에 나쁜 영향을 주는 요인이지만 `accept()` 메소드로 클라이언트와 접속을 맺는 것도 상당히 느린 작업이다.

- 따라서 Accept 에 해당하는 부분은 별도의 스레드와 셀렉터로 분리시켜서 클라이언트의 접속을 전담하게 만드는 것이 필요하다.
- 필요하다면 나머지 이벤트(Connect, Read, Write)도 각각의 별도 처리 로직으로 분리하는 것이 대용량 서버에서는 유리하다.

## 2. SelectorPool 사용

- 만 명 정도의 동시접속자가 항상 유지될 정도로 사용자의 접속, 해제가 빈번한 서버를 개발해야 한다고 생각해보자.
- Accept 부분을 별도의 셀렉터로 분리해도 접속 자체가 워낙 빈번하면 Accept 부분에서 병목이 일어날 것이다.

- 이런 경우에는 Accpet 를 수행하는 셀렉터를 n개로 만들어서 사용하는 것이 효과적이다.

- Read 를 수행하는 셀럭터가 단 하나뿐인데, 동시접속자가 훨씬 많다면 관리할 채널이 너무 많기 때문에 셀렉터 효율이 떨어질 것이다.

- 따라서 이 부분도 Read 를 수행하는 셀렉터를 n개로 만들어서 사용하는 것이 효과적이다.

> [!note]
> 이렇게 병목부분이 될 수 있는 부분인 셀렉터에 대해 그 사용 빈도나 관리 채널의 개수에 따라 일정한 한도 안에서 자동적으로 셀렉터의 개수가 늘어나거나 줄어들도록 SelectorPool 을 만들어 사용하면 서버의 성능 향상에 많은 도움이 될 것이다.

## 3. ThreadPool 사용

```java
private void accept(SelectionKey key) {
	ServerSocketChannel server = (ServerSocketChannel) key.channel();
	SocketChannel sc;
	try {
		// 서버소켓채널의 accept() 메소드로 서버소켓을 생성한다.
		sc = server.accept();
		// 생성된 소켓채널을 비블록킹과 읽기 모드로 셀렉터에 등록한다.
		registerChannel(selector, sc, SelectionKey.OP_READ);
		info(sc.toString() + " 클라이언트가 접속했습니다.");
	} catch (ClosedChannelException e) {
		log(Level.WARNING, "SimpleChatServer.accept()", e);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.accept()", e);
	}
}
```

```java
private void read(SelectionKey key) {
	// SelectionKey로부터 소켓채널을 얻어온다.
	SocketChannel sc = (SocketChannel) key.channel();
	// ByteBuffer를 생성한다.
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
	try {
		// 요청한 클라이언트의 소켓채널로부터 데이터를 읽어들인다.
		int read = sc.read(buffer);
		info(read + " byte 를 읽었습니다.");
	} catch (IOException e) {
		try {
			sc.close();
		} catch (IOException e1) {
		}
		removeUser(sc);

		info(sc.toString() + " 클라이언트가 접속을 해제했습니다.");
	}

	try {
		// 클라이언트가 보낸 메시지를 채팅방 안에 모든 사용자에게 브로드캐스트해준다.
		broadcast(buffer);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.broadcast()", e);
	}
	// 버퍼 메모리를 해제해준다.
	clearBuffer(buffer);
}
```

- 위 코드 두개 모두 요청을 싱글 스레드로 처리하고 있다.
- 이 부분 역시 ThreadPool 을 사용해서 스레드 여러 개로 동시에 처리할 수 있게 만들면 성능을 향상시킬 수 있다.

- Accept 를 처리하는 것과 Processe 를 처리하는 것으로 나눠서 별도의 독립적인 ThreadPool 로 운영되게 하자.
- 그러면 병목지점이 되는 곳을 파악했을 경우, 그 쪽의 스레드 개수를 늘리는 방식으로 쉽게 튜닝할 수 있다.

# 05. 향상된 서버 만들기






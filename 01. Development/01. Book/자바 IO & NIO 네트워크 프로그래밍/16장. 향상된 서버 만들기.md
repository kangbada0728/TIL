---
tags:
  - 학습정리
  - SLiPP_25차_스터디
  - Java
  - Network
  - 책_자바_IO_NIO_네트워크_프로그래밍
---
# 01. 들어기에 앞서

- NIO 에서 제공해주는 단순한 형태로 서버를 만들면 성능 극대화에 장애가 되는 부분들이 발생한다.
- 이 장에서는 그런 부분에 대해 이야기하고, 해결책에 대해 설명한다.

# 02. 효율적인 메모리 사용

```java
private void read(SelectionKey key) {
	// SelectionKey 로부터 소켓채널을 얻어온다.
	SocketChannel sc = (SocketChannel) key.channel();
	// ByteBuffer를 생성한다.
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024); // 중요
	try {
		// 요청한 클라이언트의 소켓채널로부터 데이터를 읽어들인다.
		int read = sc.read(buffer);
		info(read + " byte 를 읽었습니다.");
	} catch (IOException e) {
		try {
			sc.close();
		} catch (IOException el) {
		}
		
		removeUser(sc);
		
		info(sc.toString() + " 클라이언트가 접속을 해제했습니다.");
	}

	try {
		// 클라이언트가 보낸 메시지를 채팅방 안에 모든 사용자에게 브로드캐스트해준다.
		broadcast(buffer);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.broadcast()", e);
	}

	// 버퍼 메모리를 해제시킨다.
	clearBuffer(buffer); // 중요
}

private void clearBuffer(ByteBuffer buffer) {
	if (buffer != null) {
		buffer.clear();
		buffer = null;
	}
}
```

`중요` 라고 주석을 추가해놓은 부분을 보면 클라이언트들이 보낸 메시지를 처리할 때마다 매번 ByteBuffer 를 생성해서 사용하고, 사용이 끝나면 이 버퍼를 null 로 만들어서 가비지 컬렉션 대상으로 만든다.

이 방법은 매번 가비지를 생성하게 된다.

따라서 이 부분을 재사용하는 것이 필요하다.
14장의 메모리 매핑을 설명하는 곳에서 만든 ByteBufferPool 을 이곳에서 사용하면 효율적으로 메모리를 재사용할 수 있다.
매번 ByteBuffer 객체의 생성, 해제에 따른 가비지 생성 부담도 줄어들 것이다.

다이렉스 ByteBuffer 를 생성하는 것은 상당히 느린 작업이고, 이 문제는 ByteBufferPool 을 사용하여 해결할 수 있다.

# 03. 비효율적인 데이터 전송에 대한 고려

# 04. 동시성을 이용한 성능 극대화

- 단일 스레드를 이용하는 것 보다 멀티 스레드를 이용하는 것이 동시 접속자를 처리하기에 효율적이다.
- 어떻게 스레드를 활용하는지 보자.

## 1. Accept, Process 의 분리

```java
SelectionKey key = (SelectionKey) it.next();
if (key.isAcceptable()) {
	// 서버 소켓채널에 클라이언트가 접속을 시도한 경우
	accept(key);
} else if (key.isReadable()) {
	// 이미 연결된 클라이언트가 메시지를 보낸 경우
	read(key);
}
```

- 위 코드는 매번 클라이언트가 접속한 것인지 또는 클라이언트가 메시지를 보낸 것인지를 판단해서 처리하고 있다.
- 어떤 요청인지 검사하는 것도 성능에 나쁜 영향을 주는 요인이지만 `accept()` 메소드로 클라이언트와 접속을 맺는 것도 상당히 느린 작업이다.

- 따라서 Accept 에 해당하는 부분은 별도의 스레드와 셀렉터로 분리시켜서 클라이언트의 접속을 전담하게 만드는 것이 필요하다.
- 필요하다면 나머지 이벤트(Connect, Read, Write)도 각각의 별도 처리 로직으로 분리하는 것이 대용량 서버에서는 유리하다.

## 2. SelectorPool 사용

- 만 명 정도의 동시접속자가 항상 유지될 정도로 사용자의 접속, 해제가 빈번한 서버를 개발해야 한다고 생각해보자.
- Accept 부분을 별도의 셀렉터로 분리해도 접속 자체가 워낙 빈번하면 Accept 부분에서 병목이 일어날 것이다.

- 이런 경우에는 Accpet 를 수행하는 셀렉터를 n개로 만들어서 사용하는 것이 효과적이다.

- Read 를 수행하는 셀럭터가 단 하나뿐인데, 동시접속자가 훨씬 많다면 관리할 채널이 너무 많기 때문에 셀렉터 효율이 떨어질 것이다.

- 따라서 이 부분도 Read 를 수행하는 셀렉터를 n개로 만들어서 사용하는 것이 효과적이다.

> [!note]
> 이렇게 병목부분이 될 수 있는 부분인 셀렉터에 대해 그 사용 빈도나 관리 채널의 개수에 따라 일정한 한도 안에서 자동적으로 셀렉터의 개수가 늘어나거나 줄어들도록 SelectorPool 을 만들어 사용하면 서버의 성능 향상에 많은 도움이 될 것이다.

## 3. ThreadPool 사용

```java
private void accept(SelectionKey key) {
	ServerSocketChannel server = (ServerSocketChannel) key.channel();
	SocketChannel sc;
	try {
		// 서버소켓채널의 accept() 메소드로 서버소켓을 생성한다.
		sc = server.accept();
		// 생성된 소켓채널을 비블록킹과 읽기 모드로 셀렉터에 등록한다.
		registerChannel(selector, sc, SelectionKey.OP_READ);
		info(sc.toString() + " 클라이언트가 접속했습니다.");
	} catch (ClosedChannelException e) {
		log(Level.WARNING, "SimpleChatServer.accept()", e);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.accept()", e);
	}
}
```

```java
private void read(SelectionKey key) {
	// SelectionKey로부터 소켓채널을 얻어온다.
	SocketChannel sc = (SocketChannel) key.channel();
	// ByteBuffer를 생성한다.
	ByteBuffer buffer = ByteBuffer.allocateDirect(1024);
	try {
		// 요청한 클라이언트의 소켓채널로부터 데이터를 읽어들인다.
		int read = sc.read(buffer);
		info(read + " byte 를 읽었습니다.");
	} catch (IOException e) {
		try {
			sc.close();
		} catch (IOException e1) {
		}
		removeUser(sc);

		info(sc.toString() + " 클라이언트가 접속을 해제했습니다.");
	}

	try {
		// 클라이언트가 보낸 메시지를 채팅방 안에 모든 사용자에게 브로드캐스트해준다.
		broadcast(buffer);
	} catch (IOException e) {
		log(Level.WARNING, "SimpleChatServer.broadcast()", e);
	}
	// 버퍼 메모리를 해제해준다.
	clearBuffer(buffer);
}
```

- 위 코드 두개 모두 요청을 싱글 스레드로 처리하고 있다.
- 이 부분 역시 ThreadPool 을 사용해서 스레드 여러 개로 동시에 처리할 수 있게 만들면 성능을 향상시킬 수 있다.

- Accept 를 처리하는 것과 Processe 를 처리하는 것으로 나눠서 별도의 독립적인 ThreadPool 로 운영되게 하자.
- 그러면 병목지점이 되는 곳을 파악했을 경우, 그 쪽의 스레드 개수를 늘리는 방식으로 쉽게 튜닝할 수 있다.

# 05. 향상된 서버 만들기

앞서 공부한 내용을 적용시켜보자.

![[자바 IO & NIO 네트워크 프로그래밍 - 그림 16-1.png]]

패키지 구조는 크게 event, pool, queue, server, util 패키지가 존재한다.

## 패키지 구조

### event

- 이 패키지에는 서버에서 발생하는 이벤트 형식을 정의하고 있는 NIOEvent 인터페이스와 
- 이렇게 발생된 이벤트를 처리하기 위해 사용할 Job 클래스가 있다.
- AdvancedChatServer 는 두 가지 이벤트만을 처리하는데,
	- 클라이언트가 서버로 Accept 하는 것과 
	- 클라이언트가 보낸 메시지를 Read 하는 것이다.
### pool

- AdvancedChatServer 가 기존 서버보다 더 뛰어난 성능을 보일 수 있는 핵심적인 역할을 하는 클래스들을 담은 곳이다.

- ByteBufferPool
	- 14장의 파일매핑 부분과 같다.
	- 다만 여기서는 인터페이스를 이용하였다.

- ThreadPool
	- accept, read/write 를 처리한다.
	- accept 스레드는 서버에 접속한 클라이언트들을 처리한는 역할을 한다.
	- read/write 스레드는 클라이언트가 보낸 메시지를 해당 서버에 접속한 모든 클라이언트들에게 브로드캐스트하는 역할을 한다.

- SelectorPool
	- accept 와 read 두 가지가 존재한다.
	- 준비된 채널들을 빠르게 처리해주기 위해서 별도의 스레드들이 위 두 가지 셀렉션을 처리하게 만든 것이다.

### queue

- 셀렉터에서 준비된 이벤트들은 스레드들이 다이렉트로 처리할 수 없다.
- 생성자-소비자 패털을 사용해서 셀렉터와 스레드를 연관시키는 것이다.

- 그리고 이 서버에 접속한 전체 사용자들을 등록하기 위해 ChattingRoom 이라는 Vector 를 상속한 클래스를 만들어 사용했다.

### server

- AdvancedChatServer 서버를 실행시키는 클래스가 위치한 패키지
- 서버가 실행되는 데 필요한 각 클래스들을 초기화하고 이들을 시작시키는 역할만을 한다.

### util








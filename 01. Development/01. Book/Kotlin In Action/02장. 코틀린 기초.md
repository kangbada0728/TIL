---
tags:
  - 학습정리
  - 책_Kotlin_In_Action
  - Kotlin
---
**2장에서 다루는 내용**

- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기

# 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {  
    print("Hello, world!")  
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.
	- 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지이다.
	- 코틀린에는 배열 처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println 이라고 쓴다.
	- 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 Wrapper 를 제공한다.
- 줄 끝에 세미콜론을 붙이지 않아도 된다.

### 2.1.2 함수

- 함수 선언은 fun 키워드로 시작한다.
- fun 다음에는 함수 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론으로 구분해야 한다.

![[Kotlin In Action - 그림 2.1 코틀린 함수 정의.png|400]]

> [!tip] 문(statement)과 식(expression)의 구분
> 코틀린에서 If 는 식이지 문이 아니다.
> - 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
> - 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.
	- 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
	- 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.
	- 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다.
	- 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 버그가 생기는 경우가 없다.

#### 식이 본문인 함수

```kotlin
// 블록이 본문인 함수
fun max(a: Int, b: Int): Int {
	return if (a > b) a else b
}
```

```kotlin
// 식이 본문인 함수
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 앞선 max 함수 예제에서는 본문이 if 식 하나로만 이뤄져 있다.
- 이런 경우 중괄호를 없애고 return 을 제거하면서 등호를 식 앞에 붙여 더 간결하게 함수를 표현할 수 있다.

> [!summary]
> - "블록이 본문인 함수" 란 본문이 중괄호로 둘러싸인 함수
> - "식이 본문인 함수" 란 등호와 식으로 이뤄진 함수

- 코틀린에서는 식이 본문인 함수가 자주 쓰인다.

- 식이 본문인 함수의 반환 타입만 생략 가능하다.
- 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.

### 2.1.3 변수

- 타입으로 변수 선언을 시작하면 타입을 생략할 경우 식과 변수 선언을 구별할 수 없다.
- 그런 이유로 코틀린에서는 키워드로 변수 선언을 시작하는 대신 변수 이름 뒤에 타입을 명시하거나 생략하게 허용한다.

- 코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
- 물론 타입을 명시해도 된다.

```kotlin
val question = "테스트" // String 타입
val answer: Int = 42 // Int 타입
val yearsToCompute = 7.5e6 // Double 타입
```

- 초기화 식을 사용하지 않고 변수를 선언하려면 변수 타입을 반드시 명시해야 한다.
- 초기화 식이 없다면 변수에 저장될 값에 대한 정보가 없어 컴파일러가 타입을 추론할 수 없기 때문이다.

#### 변경 가능한 변수와 변경 불가능한 변수

변수 선언 시 사용하는 키워드는 2가지가 있다.

> [!summary] val 키워드
> 변경 불가능한(immutable) 참조

> [!summary] var 키워드
> 변경 가능한(mutable) 참조

> [!important]
> 기본적으로는 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때에만 var 로 변경하라.
	변경 불가능한 참조와 변경 불가능한 객체를 부수 효과가 없는 함수와 조합해 사용하면 코드가 함수형 코드에 가까워진다.

- val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.
- 하지만 어떤 블록이 실행될 때 오직 한 초기화 문장만 실행됨을 컴파일러가 확인할 수 있다면 조건에 따라 val 값을 다른 여러 값을 초기화할 수도 있다.

```kotlin
val message: String  
if (canPerformOperation()) {  
    message = "Success"  
}  
else {  
    message = "Failed"  
}
```

- val 참조 자체는 불변이어도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다.

```kotlin
val language = arrayListOf("Java")  
language.add("Kotlin")
```

- var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
- 컴파일러는 변수 선언 시점의 초기화 식으로부터 변수의 타입을 추론하며, 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

```kotlin
var answer = 42
answer = "no answer" // Error: type mismatch 컴파일 오류 발생
```

- 어떤 타입의 변수에 다른 타입의 값을 저장하고 싶다면 변환 함수를 써서 값을 변수의 타입으로 변환하거나, 값을 변수에 대입할 수 있는 타입으로 강제 형 변환(coerce)해야 한다.

### 2.1.4 더 쉽게 문자열 형식 지정: 문자열 템플릿

- 코틀린에서도 변수를 `${}` 를 이용하여 문자열 안에 사용할 수 있다.

```kotlin
val name = if (args.size > 0) args[0] else "Kotlin"  
println("Hello, $name")   // 결과는 같다.
println("Hello, ${name}") // 결과는 같다.
```

- 컴파일러는 각 식을 정적으로 (컴파일 시점에) 검사하기 때문에 존재하지 않는 변수를 문자열 템플릿 안에서 사용하면 컴파일 오류가 발생한다.

- 문자열 템플릿 안에 사용할 수 있는 대상은 간단한 변수 이름만으로 한정되지 않는다.
- 복잡한 식도 중괄호({})로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.

>[!warning] 한글을 문자열 템플릿에서 사용할 경우 주의할 점
>- 코틀린에서는 자바와 마찬가지로 한글(또는 글자로 분류할 수 있는 모든 유니코드 문자)을 식별자에 사용할 수 있으므로 변수 이름에 한글이 들어갈 수 있다.
>- 그런 유니코드 변수 이름으로 인해 문자열 템플릿을 볼 때 오해가 생길 수 있다.
>- 문자열 템플릿 안에 $ 로 변수를 지정할 때 변수명 바로 뒤에 한글을 붙여서 사용하면 코틀린 컴파일러는 영문자와 한글을 한꺼번에 식별자로 인식해서 unresolved reference 오류를 발생시킨다.
>---
>- 이 문제를 해결하는 방법은 변수 이름을 {} 로 감싸는 것이다.
>- 문자열 템플릿 안에서 변수 이름만 사용하는 경우라도 ${name} 처럼 중괄호로 변수명을 감싸는 습관을 들이면 더 좋다.
>- 필요할 때 정규식 등을 통해 검색하거나 일괄 변환할 때도 중괄호를 쓴 경우 처리가 더 쉽고, 코드를 사람이 읽을 때도 문자열 템플릿 안에서 변수가 쓰인 부분을 더 쉽게 식별할 수 있다.

- 중괄호로 둘러싼 식 안에서 큰 따옴표를 사용할 수도 있다.





---
tags:
  - 학습정리
  - 책_Kotlin_In_Action
  - Kotlin
---
**2장에서 다루는 내용**

- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기

# 2.1 기본 요소: 함수와 변수

### 2.1.1 Hello, World!

```kotlin
fun main(args: Array<String>) {  
    print("Hello, world!")  
}
```

- 함수를 선언할 때 fun 키워드를 사용한다.
- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.
- 함수를 최상위 수준에 정의할 수 있다.
	- 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.
- 배열도 일반적인 클래스와 마찬가지이다.
	- 코틀린에는 배열 처리를 위한 문법이 따로 존재하지 않는다.
- System.out.println 대신에 println 이라고 쓴다.
	- 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 Wrapper 를 제공한다.
- 줄 끝에 세미콜론을 붙이지 않아도 된다.

### 2.1.2 함수

- 함수 선언은 fun 키워드로 시작한다.
- fun 다음에는 함수 이름이 온다.
- 함수 이름 뒤에는 괄호 안에 파라미터 목록이 온다.
- 함수의 반환 타입은 파라미터 목록의 닫는 괄호 다음에 오는데, 괄호와 반환 타입 사이를 콜론으로 구분해야 한다.

![[Kotlin In Action - 그림 2.1 코틀린 함수 정의.png|400]]

> [!tip] 문(statement)과 식(expression)의 구분
> 코틀린에서 If 는 식이지 문이 아니다.
> - 식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있다.
> - 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.
	- 자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다.
	- 제어 구조를 다른 식으로 엮어낼 수 있으면 여러 일반적인 패턴을 아주 간결하게 표현할 수 있다.
	- 반면 대입문은 자바에서는 식이었으나 코틀린에서는 문이 됐다.
	- 그로 인해 자바와 달리 대입식과 비교식을 잘못 바꿔 버그가 생기는 경우가 없다.

#### 식이 본문인 함수

```kotlin
// 블록이 본문인 함수
fun max(a: Int, b: Int): Int {
	return if (a > b) a else b
}
```

```kotlin
// 식이 본문인 함수
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

- 앞선 max 함수 예제에서는 본문이 if 식 하나로만 이뤄져 있다.
- 이런 경우 중괄호를 없애고 return 을 제거하면서 등호를 식 앞에 붙여 더 간결하게 함수를 표현할 수 있다.

> [!summary]
> - "블록이 본문인 함수" 란 본문이 중괄호로 둘러싸인 함수
> - "식이 본문인 함수" 란 등호와 식으로 이뤄진 함수

- 코틀린에서는 식이 본문인 함수가 자주 쓰인다.

- 식이 본문인 함수의 반환 타입만 생략 가능하다.
- 블록이 본문인 함수가 값을 반환한다면 반드시 반환 타입을 지정하고 return문을 사용해 반환 값을 명시해야 한다.




---
tags:
  - 학습정리
  - 책_Kotlin_In_Action
  - Kotlin
---
**4장에서 다루는 내용**

- 클래스와 인터페이스
- 뻔하지 않은 생성자와 프로퍼티
- 데이터 클래스
- 클래스 위임
- object 키워드 사용

# 4.1 클래스 계층 정의

### 4.1.1 코틀린 인터페이스

- 코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의할 수 씨다.
- 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

- 코틀린에서 클래스는 `class` 로 정의하고, 인터페이스는 `interface` 를 사용한다.

```kotlin
interface Clickable {  
    fun click()  
}  
  
class Button : Clickable {  
    override fun click() = println("I was clicked")  
}
```

- 인터페이스를 구현하는 모든 비추상 클래스(또는 구체적 클래스)는 `click` 에 대한 구현을 제공해야 한다.

- 코틀린에서는 클래스 이름 뒤에 콜론(`:`)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

- 클래스는 하나만 확장 가능, 인터페이스는 제한 없이 구현 가능

- `override` 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 오버라이드 한다는 표시다.
- 코틀린에서는 `override` 변경자가 필수
- `override` 변경자는 실수로 상위 클래스의 메서드를 오버라이드하는 경우를 방지해준다.
	- 만약 `override` 변경자 없이 상위 클래스와 하위 클래스의 메서드 시그니처가 같으면 컴파일이 안된다.

- 인터페이스 메서드에서 디폴트 구현을 제공할 수 있다.
- 특별한 키워드 없이 메서드 본문을 메서드 시그니처 뒤에 추가하면 된다.

```kotlin
interface Clickable {  
    fun click()  
    fun showOff() = println("I'm clickable!")  
}
```

- 인터페이스 구현체는 새로운 동작을 정의할 수도 있고, 디폴트 구현을 사용할 수도 있다.

```kotlin
interface Clickable {  
    fun click()  
    fun showOff() = println("I'm clickable!") // 시그니처가 같다.
}  
  
interface Focusable {  
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")  
    fun showOff() = println("I'm focusable!") // 시그니처가 같다.
}
```

- 위 인터페이스를 동시에 구현하는 클래스에서는 어떤 `showOff` 메서드가 실행될까?
- 어느 쪽도 선택되지 않는다.
- 클래스가 구현하는 두 상위 인터페이스에 정의된 `showOff` 구현을 대체할 오버라이딩 메서드를 직접 제공하지 않으면 컴파일러 오류가 발생한다.
- 코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

![[Kotlin In Action - 리스트 4.5.png]]

- 위 코드에서 `Button` 은 상속한 두 상위 타입의 `showOff()` 메서드를 호출하는 방식으로 `showOff()` 를 구현한다.
- 상위 타입의 구현을 호출할 때는 `super` 를 사용한다.
- 구체적으로 타입을 지정할 때는 꺽쇠 괄호 안에 기반 타입 이름을 지정한다.
	- Java : `Clickable.super.showOff()`
	- Kotlin : `super<Clickable>.showOff()`

- 상속한 구현 중 단 하나만 호출해도 된다면 블록 없이 쓸 수도 있다.
	- ex) `override fun showOff() = super<Clickable>.showOff()`

> [!note] 자바에서 코틀린의 메서드가 있는 인터페이스 구현하기
> 코틀린은 자바 6와 호환되게 설계됐다. 따라서 인터페이스의 디폴트 메서드를 지원하지 않는다.
> 
> 따라서 코틀린은 디폴트 메서드가 있는 인터페이스를 일반 인터페이스와 디폴트 메서드 구현이 정적 메서드로 들어있는 클래스를 조합해 구현한다.
> 인터페이스에는 메서드 선언만 들어가며, 인터페이스와 함께 생성되는 클래스에는 모든 디폴트 메서드 구현이 정적 메서드로 들어간다.
> 
> 그러므로 디폴트 인터페이스가 포함된 코틀린 인터페이스를 자바 클래스에서 상속해 구현하고 싶다면 코틀린에서 메서드 본문을 제공하는 메서드를 포함하는 모든 메서드에 대한 본문을 작성해야 한다.
> 
> 하지만 코틀린 1.5 부터는 코틀린 컴파일러가 자바 인터페이스의 디폴트 메서드를 생성해준다.

### 4.1.2 open, final, abstract 변경자: 기본적으로 final

- 클래스 상속은 편리하지만 문제가 생기는 경우도 많다.

> [!note] 취약한 기반 클래스(fragile base class) 문제
> 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우 발생한다.
	어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙(어떤 메서드를 어떻게 오버라이드해야 하는지 등)을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험이 있다.

- 위 문제를 해결 하기 위해서는 "상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지" 하는 것이 좋다.
- 코틀린은 위 철학을 따른다.
- 코틀린의 클래스와 메서드는 기본적으로 `final`  이다.

- 어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다.
- 그와 더불어 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 `open` 변경자를 붙여야 한다.

![[Kotlin In Action - 리스트 4.6.png]]

- 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메서드는 기본적으로 열려있다.
- 오버라이드하는 메서드의 구현을 하위 클래스에서 오버라이드 못하게 금지하려면 오버라이드하는 메서드 앞에 final 을 명시해야 한다.

![[Kotlin In Action - 리스트 4.7.png]]

> [!note] 열린 클래스와 스마트 캐스트
> 클래스의 기본적인 상속 가능 상태를 `final` 로 함으로써 얻을 수 있는 장점은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
> 
> 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다.
> 클래스 프로퍼티의 경우 이는 `val` 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미다.
> 이 요구 사항은 또한 프로퍼티가 `final` 이어야만 한다는 뜻이기도 하다.

- 코틀린에서도 클래스를 `abstract` 로 선언할 수 있다.
- `abstract` 로 선언한 추상 클래스는 인스턴스화할 수 없다.
- 추상 멤버는 항상 열려있다.
	- 따라서 추상 멤버 앞에 `open` 변경자를 명시할 필요가 없다.

![[Kotlin In Action - 리스트 4.8.1.png]]
![[Kotlin In Action - 리스트 4.8.2.png]]

- 아래 표에 있는 설명을 클래스 멤버에 대해 적용할 수 있다.

![[Kotlin In Action - 표 4.1.png]]

- 인터페이스 멤버의 경우 `final`, `open`, `abstract`  를 사용하지 않는다.
- 인터페이스 멤버는 항상 열려 있으며 `final` 로 변경할 수 없다.
- 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 된다.
	- 그렇더라도 따로 멤버 선언 앞에 `abstract` 키워드를 덧붙일 필요가 없다.

### 4.1.3 가시성 변경자: 기본적으로 공개

> [!note] 가시성 변경자(visibility modifier)란
> 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.

- 코틀린의 기본 가시성은 공개(`public`)이다.

- 자바의 기본 가시성인 패키지 전용(`package-private`)은 코틀린에 없다.
- 코틀린은 패키지를 네임스페이스(namespace)를 관리하기 위한 용도로만 사용한다.
- 그래서 패키지를 가시성 제어에 사용하지 않는다.

- 패키지 전용 가시성에 대한 대안으로 코틀린에는 `internal`(모듈 내부) 이라는 새로운 가시성 변경자를 도입했다.
- `internal` 은 "모듈 내부에서만 볼 수 있음" 이라는 뜻이다.
- 모듈(module)은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.
	- IntelliJ, Eclipse, Maven, Gradle 등의 프로젝트가 모듈이 될 수 있다.
	- 앤트 테스크가 한 번 실행될 때 함께 컴파일되는 파일의 집합도 모듈이 될 수 있다.

- 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다.
- 자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에 있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있다.
	- 그래서 모듈의 캡슐화가 쉽게 깨진다.

- 코틀린에서는 최상위 선언에 대해 `private` 가시성(비공개 가시성)을 허용한다.
- 그런 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.
- 비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다.

![[Kotlin In Action - 표 4.2.png]]

![[Kotlin In Action - 코드 4.1.png]]

위 예제를 보자.
- `TalkativeButton` 은 internal 의 가시성을 가지고 있는데 반해, `giveSpeech` 는 public 이라는 더 높은 가시성을 가지고 있다.
- 이런 경우 `giveSpeech` 는 `TalkativeButton` 을 참조하지 못한다.
- 즉, 가시성이 높은 함수에서 가시성이 낮은 타입을 참조할 수 없어 컴파일 오류가 날 것이다.
- 이를 피하려면 `giveSpeech` 확장 함수의 가시성을 `internal` 로 바꾸거나, `TalkativeButton` 클래스의 가시성을 `public` 으로 바꿔야 한다.

> [!important] 
> 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 하고,
> 
> 메서드의 시그니처에 사용된 모든 타입의 가시성은 그 메서드의 가시성과 같거나 더 높아야 한다.
	이런 규칙은 어떤 함수를 호출하거나 어떤 클래스를 확장할 때 필요한 모든 타입에 접근할 수 있게 보장해준다.

- 자바에서는 같은 패키지 안에서 `protected` 멤버에 접근할 수 있다.
- 하지만 코틀린에서 `protected` 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다.

- 클래스를 확장한 함수는 그 클래스의 `private` 이나 `protected` 멤버에 접근할 수 없다.

> [!note] 코틀린의 가시성 변경자와 자바
> 코틀린의 `public`, `protected`, `private`  변경자는 컴파일된 자바 바이트코드 안에서도 그대로 유지된다.
> 그렇게 컴파일된 코틀린 선언의 가시성은 마치 자바에서 똑같은 가시성을 사용해 선언한 경우와 같다.
> 
> 유일한 예외는 `private`  클래스다.
> 자바에서는 클래스를 `private` 으로 만들 수 없으므로 내부적으로 코틀린은 `private` 클래스를 `default`(패키지-전용) 클래스로 컴파일한다.
> ---
> 자바에는 `internal` 에 딱 맞는 가시성이 없다.
> 
> `default`(패키지-전용) 가시성은 `internal` 과는 전혀 다르다.
> 모듈은 보통 여러 패키지로 이뤄지며 서로 다른 모듈에 같은 패키지에 속한 선언이 들어 있을 수도 있다.
> 따라서 `internal` 변경자는 바이트코드상에서는 `public` 이 된다.
> ---
> 코틀린 선언과 그에 해당하는 자바 선언(또는 바이트코드 표현)에 이런 차이가 있기 때문에 
> 코틀린에서는 접근할 수 없는 대상을 자바에서 접근할 수 있는 경우가 생긴다.
> 
> 예를 들어 다른 모듈에 정의된 `internal` 클래스나 `internal` 최상위 선언을 모듈 외부의 자바 코드에서 접근할 수 있다.
> 또한 코틀린에서 `protected` 로 정의한 멤버를 코틀린 클래스와 같은 패키지에 속한 자바 코드에서는 접근할 수 **있다**(이는 자바에서 자바 `protected` 멤버에 접근하는 경우와 같다).
> ---
> 하지만 코틀린 컴파일러가 `internal` 멤버의 이름을 보기 나쁘게 바꾼다는(mangle) 사실을 기억하자.
> 그로 인해 기술적으로는 `internal` 멤버를 자바에서 문제없이 사용할 수 있지만, 멤버 이름이 보기 불편하고 코드가 못생겨 보인다.
> 
> 이렇게 이름을 바꾸는 이유는 두 가지다.
> 1. 한 모듈에 속한 어떤 클래스를 모듈 밖에서 상속한 경우 그 하위 클래스 내부의 메서드 이름이 우연히 상위 클래스의 `internal` 메서드와 같아져서 내부 메서드를 오버라이드하는 경우를 방지하기 위함이다.
> 2. 실수로 `internal` 클래스를 모듈 외부에서 사용하는 일을 막기 위함이다.

- 코틀린과 자바 가시성 규칙의 또 다른 차이는
- 코틀린에서는 외부 클래스가 내부 클래스나 중첩된 클래스의 `private` 멤버에 접근할 수 없다는 점이다.

### 4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

> [!note]
> 코틀린의 중첩 클래스(nested class)는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근권한이 없다.

- 이는 [[Inner class 직렬화하기|중첩 클래스가 묵시적으로 바깥쪽 클래스를 참조하고 있는 자바]]하고는 정반대이다.

- 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 `static` 중첩 클래스와 같다.
- 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들고 싶다면 `inner` 변경자를 붙여야 한다.

![[Kotlin In Action - 표 4.3.png]]

![[Kotlin In Action - 그림 4.1.png]]

- 코틀린 내부 클래스 `Inner` 안쪽에서 바깥쪽 클래스 `Outer` 의 참조에 접근하려면 `this@Outer` 라고 써야 한다.

```kotlin
class Outer {
	inner class Inner {
		fun getOuterReference(): Outer = this@Outer
	}
}
```

- 클래스 계층을 만들되 그 계층에 속한 클래스의 수를 제한하고 싶은 경우 중첩 클래스를 쓰면 편리하다.

### 4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

![[Kotlin In Action - 리스트 4.12.png|500]]

- 코틀린 컴파일러는 `when` 을 사용해 `Expr` 타입의 값을 검사할 때 꼭 디폴트 분기인 `else` 분기를 덧붙이게 강제한다.
- `else` 분기에서 반환할 만한 의미 있는 값이 없으면 예외를 던진다.

- 항상 디폴트 분기를 추가하는 게 편하지는 않다.
- 릐고 디폴트 분기가 있으면 새로운 하위 클래스를 추가하더라도 컴파일러가 `when` 이 모든 경우를 처리하는지 제대로 검사할 수 없다.
- 실수로 새로운 클래스 처리를 잊어버리면 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수도 있다.

- 코틀린은 이런 문제를 방지하기 위해 `sealed` 클래스를 만들었다.
- 상위 클래스에 `sealed` 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다.
- `sealed` 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다.

![[Kotlin In Action - 리스트 4.13.png]]

- `when` 식에서 `sealed` 클래스의 모든 하위 클래스를 처리한다면 디폴트 분기(`else` 분기)가 필요 없다.
- `sealed` 로 표시된 클래스는 자동으로 `open` 이다.
	- 따라서 별도로 `open` 변경자를 붙일 필요가 없다.

![[Kotlin In Action - 그림 4.2.png]]

- 봉인된 클래스는 클래스 외부에 자신을 상속한 클래스를 둘 수 없다.

- `sealed` 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 `when` 식을 사용하면 나중에 `sealed` 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 `when` 식이 컴파일되지 않는다.
- 따라서 `when` 식을 고쳐야 한다는 사실을 쉽게 알 수 있다.


![[Kotlin In Action - 코드 4.2.png]]

- 내부적으로 `Expr` 클래스는 `private` 생성자를 가진다.
- 그 생성자는 클래스 내부에서만 호출할 수 있다.

- `sealed` 인터페이스를 정의할 수는 없다.
	- `sealed` 인터페이스를 만들 수 있다면 그 인터페이스를 자바 쪽에서 구현하지 못하게 막을 수 있는 수단이 코틀린 컴파일러에게 없기 때문이다.

> [!note]
> 코틀린 1.0 에서 `sealed` 는 너무 제약이 심하다.
> 
> 예를 들어 모든 하위 클래스는 중첩 클래스여야 하고, 데이터 클래스로 `sealed` 클래스를 상속할 수도 없다.
>
> 코틀린 1.5 부터는 `sealed` 클래스가 정의된 패키지 안의 아무 위치(최상위, 다른 클래스나 객체나 인터페이스에 내포된 위치)에 선언할 수 있게 됐고, `sealed` 인터페이스도 추가됐다.

## 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

- 코틀린은 주(primary) 생성자와 부(secondary) 생성자를 구분한다.
	- 보통 주 생성자는 클래스를 초기화할 때 주로 사용하는 간략한 생성자로, 클래스 본문 밖에서 정의한다.
	- 부 생성자는 클래스 본문 안에서 정의한다.

- 코틀린에서는 초기화 블록(initializer block)을 통해 초기화 로직을 추가할 수 있다.

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록

```kotlin
class User(val nickname: String) // 프로퍼티 겸 생성자 파라미터
```

- 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 주 생성자(primary constructor)라고 부른다.
- 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.

- 아래 코드는 위 코드와 같은 목적을 달성할 수 있는 가장 명시적인 선언이다.
- 생성자 파라미터와 프로퍼티를 나누어놓았다.

```kotlin
class User constructor(_nickname: String) { // 생성자 파라미터
    val nickname: String // 프로퍼티
      
    init {  
        nickname = _nickname
    }  
}
```

- `constructor` 키워드
	- 주 생성자나 부 생성자 정의를 시작할 때 사용한다.

- `init` 키워드
	- 초기화 블록을 시작한다.

- 초기화 블록
	- 초기화 블록에는 클래스의 객체가 만들어질 때(인스턴스화될 때) 실행될 초기화 코드가 들어간다.
	- 초기화 블록은 주 생성자와 함께 사용된다.
	- 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다.
	- 필요하다면 클래스 안에 여러 초기화 블록을 선언할 수 있다.

- 굳이 위 코드처럼 언더바(`_`)로 프로퍼티와 생성자 파라미터를 구분하지 않고
- 자바에서 처럼 `this.nickname = nickname` 같이 생성자 파라미터와 프로퍼티의 이름을 같게 하고 프로퍼티에 `this` 를 써서 모호성을 없애도 된다.

```kotlin
class User constructor(nickname: String) {  
    val nickname: String // 이게 this.name 에 해당한다.
  
    init {  
        this.nickname = nickname  
    }  
}
```

- 위 코드에서는 `nickname` 프로퍼티를 초기화하는 코드를 `nickname` 프로퍼티 선언에 포함시킬 수 있어서 초기화 코드를 초기화 블록에 넣을 필요가 없다.
- 그리고 주 생성자 앞에 별다른 애너테이션이나 가시성 변경자가 없다면 `constructor` 를 생략해도 된다.
- 이런 변경을 적용하면 위 코드를 다음과 같이 바꿀 수 있다.

```kotlin
class User constructor(_nickname: String) {  
    val nickname = _nickname  
}
```

- 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다.

- 앞의 두 예제 코드는 클래스 본문에서 `val` 키워드를 통해 프로퍼티를 정의했다.
- 하지만 주 생성자의 파라미터로 프로퍼티를 초기화한다면, 그 주 생성자 파라미터 이름 앞에 `val` 을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.

```kotlin
class User(val nickname: String) // val 은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다.
```

- 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다.

```kotlin
class User(val nickname: String, val isSubscribed: Boolean = true)
```

- 클래스의 인스턴스를 만들려면 `new` 키워드 없이 생성자를 직접 호출하면 된다.

![[Kotlin In Action - 코드 4.3.png]]

> [!note]
> 모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다.
> 그렇게 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 사용해 클래스를 초기화한다.
> 
> 의존관계 주입(DI, Dependency Injection) 프레임워크 등 자바 라이브러리 중에는 파라미터가 없는 생성자를 통해 객체를 생성해야만 라이브러리 사용이 가능한 경우가 있다.
> 코틀린이 제공하는 파라미터 없는 생성자는 그런 라이브러리와의 통합을 쉽게 해준다.


- 클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야 할 필요가 있다.
- 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다.

```kotlin
open class User(val nickname: String)  
class TwitterUser(nickname: String) : User(nickname)
```

- 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다.

```kotlin
open class Button // 인자가 없는 디폴트 생성자가 만들어진다.
```

- `Button` 의 생성자는 아무 인자도 받지 않지만, `Button` 클래스를 상속한 하위 클래스는 반드시 `Button` 클래스의 생성자를 호출해야 한다.

```kotlin
class RadioButton: Button()
```

- 이 규칙으로 인해 기반 클래스의 이름 뒤에는 꼭 빈 괄호가 들어간다.
	- 물론 생성자 인자가 있다면 괄호 안에 인자가 들어간다.
- 반면 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 인터페이스 이름 뒤에는 아무 괄호도 없다.
- 이런 차이를 보고 클래스 정의에서 기반 클래스와 인터페이스를 구별할 수 있다.

```kotlin
open class Button  
interface Clickable  
class RadioButton: Button(), Clickable
```


- 어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막고 싶다면 모든 생성자를 `private` 으로 만들면 된다.
- 다음은 주 생성자에 `private` 변경자를 붙인 것이다.

```kotlin
class Secretive private constructor() {}
```

- `Secretive` 클래스 안에는 주 생성자밖에 없고 그 주 생성자는 비공개이므로 외부에서는 `Secretive` 를 인스턴스화할 수 없다.

- 대부분의 경우 클래스의 생성자는 아주 단순하다.
- 그래서 코틀린은 간단한 주 생성자 문법을 제공한다.
- 하지만 간단하지 않은 경우를 대비해 다양한 생성자를 정의할 수 있게 해준다.











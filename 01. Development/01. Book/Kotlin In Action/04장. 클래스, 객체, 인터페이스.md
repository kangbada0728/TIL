---
tags:
  - 학습정리
  - 책_Kotlin_In_Action
  - Kotlin
---
**4장에서 다루는 내용**

- 클래스와 인터페이스
- 뻔하지 않은 생성자와 프로퍼티
- 데이터 클래스
- 클래스 위임
- object 키워드 사용

# 4.1 클래스 계층 정의

### 4.1.1 코틀린 인터페이스

- 코틀린 인터페이스 안에는 추상 메서드뿐 아니라 구현이 있는 메서드도 정의할 수 씨다.
- 다만 인터페이스에는 아무런 상태(필드)도 들어갈 수 없다.

- 코틀린에서 클래스는 `class` 로 정의하고, 인터페이스는 `interface` 를 사용한다.

```kotlin
interface Clickable {  
    fun click()  
}  
  
class Button : Clickable {  
    override fun click() = println("I was clicked")  
}
```

- 인터페이스를 구현하는 모든 비추상 클래스(또는 구체적 클래스)는 `click` 에 대한 구현을 제공해야 한다.

- 코틀린에서는 클래스 이름 뒤에 콜론(`:`)을 붙이고 인터페이스와 클래스 이름을 적는 것으로 클래스 확장과 인터페이스 구현을 모두 처리한다.

- 클래스는 하나만 확장 가능, 인터페이스는 제한 없이 구현 가능

- `override` 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메서드를 오버라이드 한다는 표시다.
- 코틀린에서는 `override` 변경자가 필수
- `override` 변경자는 실수로 상위 클래스의 메서드를 오버라이드하는 경우를 방지해준다.
	- 만약 `override` 변경자 없이 상위 클래스와 하위 클래스의 메서드 시그니처가 같으면 컴파일이 안된다.

- 인터페이스 메서드에서 디폴트 구현을 제공할 수 있다.
- 특별한 키워드 없이 메서드 본문을 메서드 시그니처 뒤에 추가하면 된다.

```kotlin
interface Clickable {  
    fun click()  
    fun showOff() = println("I'm clickable!")  
}
```

- 인터페이스 구현체는 새로운 동작을 정의할 수도 있고, 디폴트 구현을 사용할 수도 있다.

```kotlin
interface Clickable {  
    fun click()  
    fun showOff() = println("I'm clickable!") // 시그니처가 같다.
}  
  
interface Focusable {  
    fun setFocus(b: Boolean) = println("I ${if (b) "got" else "lost"} focus.")  
    fun showOff() = println("I'm focusable!") // 시그니처가 같다.
}
```

- 위 인터페이스를 동시에 구현하는 클래스에서는 어떤 `showOff` 메서드가 실행될까?
- 어느 쪽도 선택되지 않는다.
- 클래스가 구현하는 두 상위 인터페이스에 정의된 `showOff` 구현을 대체할 오버라이딩 메서드를 직접 제공하지 않으면 컴파일러 오류가 발생한다.
- 코틀린 컴파일러는 두 메서드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다.

![[Kotlin In Action - 리스트 4.5.png]]

- 위 코드에서 `Button` 은 상속한 두 상위 타입의 `showOff()` 메서드를 호출하는 방식으로 `showOff()` 를 구현한다.
- 상위 타입의 구현을 호출할 때는 `super` 를 사용한다.
- 구체적으로 타입을 지정할 때는 꺽쇠 괄호 안에 기반 타입 이름을 지정한다.
	- Java : `Clickable.super.showOff()`
	- Kotlin : `super<Clickable>.showOff()`

- 상속한 구현 중 단 하나만 호출해도 된다면 블록 없이 쓸 수도 있다.
	- ex) `override fun showOff() = super<Clickable>.showOff()`

> [!note] 자바에서 코틀린의 메서드가 있는 인터페이스 구현하기
> 코틀린은 자바 6와 호환되게 설계됐다. 따라서 인터페이스의 디폴트 메서드를 지원하지 않는다.
> 
> 따라서 코틀린은 디폴트 메서드가 있는 인터페이스를 일반 인터페이스와 디폴트 메서드 구현이 정적 메서드로 들어있는 클래스를 조합해 구현한다.
> 인터페이스에는 메서드 선언만 들어가며, 인터페이스와 함께 생성되는 클래스에는 모든 디폴트 메서드 구현이 정적 메서드로 들어간다.
> 
> 그러므로 디폴트 인터페이스가 포함된 코틀린 인터페이스를 자바 클래스에서 상속해 구현하고 싶다면 코틀린에서 메서드 본문을 제공하는 메서드를 포함하는 모든 메서드에 대한 본문을 작성해야 한다.
> 
> 하지만 코틀린 1.5 부터는 코틀린 컴파일러가 자바 인터페이스의 디폴트 메서드를 생성해준다.

### 4.1.2 open, final, abstract 변경자: 기본적으로 final

- 클래스 상속은 편리하지만 문제가 생기는 경우도 많다.

> [!note] 취약한 기반 클래스(fragile base class) 문제
> 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우 발생한다.
	어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙(어떤 메서드를 어떻게 오버라이드해야 하는지 등)을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험이 있다.

- 위 문제를 해결 하기 위해서는 "상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지" 하는 것이 좋다.
- 코틀린은 위 철학을 따른다.
- 코틀린의 클래스와 메서드는 기본적으로 `final`  이다.

- 어떤 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 한다.
- 그와 더불어 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 `open` 변경자를 붙여야 한다.

![[Kotlin In Action - 리스트 4.6.png]]

- 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메서드는 기본적으로 열려있다.
- 오버라이드하는 메서드의 구현을 하위 클래스에서 오버라이드 못하게 금지하려면 오버라이드하는 메서드 앞에 final 을 명시해야 한다.

![[Kotlin In Action - 리스트 4.7.png]]

> [!note] 열린 클래스와 스마트 캐스트
> 클래스의 기본적인 상속 가능 상태를 `final` 로 함으로써 얻을 수 있는 장점은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
> 
> 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다.
> 클래스 프로퍼티의 경우 이는 `val` 이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미다.
> 이 요구 사항은 또한 프로퍼티가 `final` 이어야만 한다는 뜻이기도 하다.

- 코틀린에서도 클래스를 `abstract` 로 선언할 수 있다.
- `abstract` 로 선언한 추상 클래스는 인스턴스화할 수 없다.
- 추상 멤버는 항상 열려있다.
	- 따라서 추상 멤버 앞에 `open` 변경자를 명시할 필요가 없다.

![[Kotlin In Action - 리스트 4.8.1.png]]
![[Kotlin In Action - 리스트 4.8.2.png]]

- 아래 표에 있는 설명을 클래스 멤버에 대해 적용할 수 있다.

![[Kotlin In Action - 표 4.1.png]]

- 인터페이스 멤버의 경우 `final`, `open`, `abstract`  를 사용하지 않는다.
- 인터페이스 멤버는 항상 열려 있으며 `final` 로 변경할 수 없다.
- 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 된다.
	- 그렇더라도 따로 멤버 선언 앞에 `abstract` 키워드를 덧붙일 필요가 없다.
















---
tags:
  - 학습정리
  - 책_Kotlin_In_Action
  - Kotlin
---
**3장에서 다루는 내용**

- 컬렉션, 문자열, 정규식을 다루기 위한 함수
- 이름 붙인 인자, 디폴트 파라미터 값, 중위 호출 문법 사용
- 확장 함수와 확장 프로퍼티를 사용해 자바 라이브러리 적용
- 최상위 및 로컬 함수와 프로퍼티를 사용해 코드 구조화

# 3.1 코틀린에서 컬렉션 만들기

```kotlin
val set = hashSetOf(1, 4, 3)  
val list = arrayListOf(1, 7, 43)  
val map = hashMapOf(1 to "sdf", 3 to "ss", 34 to "sdf")  

println(set.javaClass)  // class java.util.HashSet
println(list.javaClass) // class java.util.ArrayList
println(map.javaClass)  // class java.util.HashMap
```

- set, list, map 에 대한 javaClass 들을 출력해보니 모두 자바 java.util 에 담겨있다.
- 즉, 코틀린은 자신만의 컬렉션 기능을 제공하지 않는다는 뜻이다.
- 자바 개발자가 기존 자바 커렉션을 활용할 수 있다는 뜻이기도 하다.

- 코틀린이 자체 컬렉션을 제공하지 않는 이유는 표준 자바 컬렉션을 활용하면 자바 코드와 상호작용하기가 훨씬 쉽기 때문이다.
- 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린 컬렉션을 서로 변화할 필요가 없다.

## 3.2 함수를 호출하기 쉽게 만들기

- 자바 컬렉션에는 디폴트 toString 구현이 들어있다.
- 하지만 그 디폴트 toString 의 출력 형식은 고정돼 있다.
- 원하는 접두사, 접미사, 구분자를 넣어 리스트를 문자열을 출력해주는 함수를 만들어보자.

- 코드를 발전시키며 알아보자.

```kotlin
fun <T> joinToString(  
    collection: Collection<T>,  
    separator: String,  
    prefix: String,  
    postfix: String  
): String {  
    val result = StringBuilder(prefix)  
    for ((index, element) in collection.withIndex()) {  
        if (index > 0) {  
            result.append(separator)  
        }  
        result.append(element)  
    }  
    result.append(postfix)  
    return result.toString()  
}
```

- 위 함수를 호출할 때마다 매번 네 인자를 모두 전달하지 않을 수는 없을까?

### 3.2.1 이름 붙인 인자

- 위 코드의 첫 번째 문제는 **함수 호출 부분의 가독성**이다.
- `joinToString(collection, " ", " ", ".")` 라는 코드가 있다면 각 인자들이 어떤 역할을 하는지 그냥 봐서는 알 수 가 없다.
- 만약 boolean 플래그 값을 전달해야 한다면 더 알기 힘들 것이다.

- 코틀린에서는 작성한 함수를 호출할 떄는 함수에 전달하는 인자 중 일부(또는 전부)의 이름을 명시할 수 있다.
- 호출 시 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 막기 위해 그 뒤에 오는 모든 인자는 이름을 명시해야 한다.

```kotlin
joinToString(collection, separator = " ", prefix = " ", postfix = ".")
```

> [!warning]
> 자바로 작성한 코드를 호출할 떄는 이름 붙인 인자를 사용할 수 없다. 따라서 JDK 가 제공하는 함수를 호출할 때도 이름 붙인 인자를 쓸 수 없다.
> 
> 클래스 파일(.class 파일)에 함수 파라미터 정보를 넣는 것은 자바 8 이후 추가된 선택적 특징인데, 코틀린은 JDK 6 와 호환된다.
> 
> 그 결과 코틀린 컴파일러는 함수 시그니처의 파라미터 이름을 인식할 수 없고, 호출 시 사용한 인자 이름과 함수 정의의 파라미터 이름을 비교할 수 없다.

### 3.2.2 디폴트 파라미터 값

- 자바에서는 일부 클래스에 오버로딩한 메서드가 너무 많아진다는 문제가 있다.
- 코틀린에서는 함수 선언에서 파라미터의 디폴트 값을 지정할 수 있으므로 이런 오버로드 중 상당수를 피할 수 있다.

```kotlin
fun <T> joinToString(  
    collection: Collection<T>,  
    separator: String = ", ",  
    prefix: String = "",  
    postfix: String = ""  
): String
```

- 이제 함수를 호출할 때 모든 인자를 쓸 수도 있고, 일부를 생략할 수도 있다.

> [!note] 디폴트 값과 자바
> 자바에는 디폴트 파라미터 값이라는 개념이 없어서 코틀린 함수를 자바에서 호출하는 경우에는 그 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다.
> 
> 자바에서 코틀린 함수를 자주 호출해야 한다면 자바 쪽에서 좀 더 편하게 코틀린 함수를 호출하고 싶을 것이다. 그럴 때 `@JvmOverloads` 을 함수에 추가할 수 있다.
> 
> `@JvmOverloads` 를 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터로부터 파라미터를 하나씩 생략한 오버로딩한 자바 메서드를 추가해준다.
> 
> 예를 들어 `joinToString` 에 `@JvmOverloads` 를 붙이면 다음과 같은 오버로딩한 함수가 만들어진다.

```java
String joinToString(Collection<T> collection, String separator, 
					String prefix, String postfix);

String joinToString(Collection<T> collection, String separator, 
					String prefix);

String joinToString(Collection<T> collection, String separator);

String joinToString(Collection<T> collection);
```









